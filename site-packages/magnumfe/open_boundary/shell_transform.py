# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-06-10

from __future__ import absolute_import 

from dolfin import *

from magnumfe.dolfin.expressions import MetricMatrix
from magnumfe.llg_terms import LLGTerm
from magnumfe.common import Constants, WrappedMesh, Cache

__all__ = ["ShellTransform"]

class ShellTransform(object):
  """
  Solver for open-boundary problems using the shell-transformation method.
  """

  def __init__(self, rhs_form, order = 1):
    """
    *Arguments*
        rhs_form (:class:`lambda`)
            Lambda that returns the RHS part of the weak form.
        order (:class:`int`)
            The order of CG function used for the potential calculation.
    """

    self.rhs_form    = rhs_form
    self.order       = order

    self._assemble_cache       = Cache()

  def calculate(self, state, *args):
    """
    Solve the open boundary problem for a given state.

    *Arguments*
        state (:math:`State`)
            The simulation state
        *args
            Additional coefficients used in the RHS form.
    """
    # prepare RHS coefficients
    rhs_coeffs = []
    #for coeff in self.rhs_coeffs(state) + list(args):
    for coeff in args:
      if isinstance(state.mesh, WrappedMesh) and isinstance(coeff, Function):
        rhs_coeffs.append(state.mesh.expand(coeff))
      else:
        rhs_coeffs.append(coeff)

    # prepare cache
    cache = self._assemble_cache
    if cache.requires_update(state):

      if isinstance(state.mesh, WrappedMesh):
        mesh = state.mesh.with_shell
        cell_domains  = MeshFunction('size_t', mesh, 3, mesh.domains())
        measure = Measure('dx', mesh)[cell_domains]
        VV = VectorFunctionSpace(mesh, 'CG', 1)
      else:
        mesh = state.mesh
        measure = None
        VV = state.VectorFunctionSpace()
  
      VS = FunctionSpace(mesh, 'CG', self.order)
  
      v = TestFunction(VS)
      u = TrialFunction(VS)
  
      transformation_order = 1 if (self.order == 1) else 2
      shell_width = mesh.coordinates().max(axis=0).min() / 2.0
      sample_size = mesh.coordinates().max(axis=0) - shell_width
      gx = MetricMatrix.create_for_cube(sample_size, 0, transformation_order)
      gy = MetricMatrix.create_for_cube(sample_size, 1, transformation_order)
      gz = MetricMatrix.create_for_cube(sample_size, 2, transformation_order)
  
      # setup RHS coefficients
      cache.rhs_coeffs = []
      for coeff in rhs_coeffs:
        result = None
        if isinstance(coeff, Constant):
          # TODO there has be to be a more elegant way
          if coeff.rank() == 0: result = Constant(0.0)
          if coeff.rank() == 1: result = Constant((0.0, 0.0, 0.0))
        elif isinstance(coeff, Function):
          result = Function(coeff.function_space())

        if result == None: raise "Coefficient type not supported"
        cache.rhs_coeffs.append(result)
  
      a = inner(grad(v), grad(u))      * state.dx('all', measure) \
        + inner(grad(v), grad(u))      * state.dx(1000, measure) \
        + inner(grad(v), gx * grad(u)) * state.dx(1001, measure) \
        + inner(grad(v), gy * grad(u)) * state.dx(1002, measure) \
        + inner(grad(v), gz * grad(u)) * state.dx(1003, measure)
  
      L = self.rhs_form(cache.rhs_coeffs, v, state, measure)
  
      cache.bc = DirichletBC(VS, Constant(0.0), DomainBoundary())
  
      cache.u = Function(VS)
  
      # set up assembler and solver objects
      cache.A, cache.b = Matrix(), Vector()
      cache.assembler = SystemAssembler(a, L, cache.bc)
      cache.assembler.assemble(cache.A)
  
      cache.solver = KrylovSolver(cache.A, "cg", "amg")
      cache.solver.parameters["nonzero_initial_guess"] = True
  
    # assign RHS coefficients
    for source, target in zip(rhs_coeffs, cache.rhs_coeffs):
      target.assign(source)

    cache.assembler.assemble(cache.b)
    cache.solver.solve(cache.u.vector(), cache.b)

    if isinstance(state.mesh, WrappedMesh):
      return state.mesh.cut(cache.u)
    else:
      return cache.u
