# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-02-25

from __future__ import absolute_import 

from dolfin import *
try:
  from bempp.lib import *
  _found_bempp = True
except:
  # TODO log warning
  _found_bempp = False

import numpy as np

from magnumfe.llg_terms import LLGTerm
from magnumfe.common import Timer, WrappedMesh, Constants, Cache, MaskedState

__all__ = ["FredkinKoehler"]

# TODO handle differnet regions
class FredkinKoehler(object):
  """
  This class defines methods for the micromagnetic stray-field computation.
  It uses the FEM-BEM coupling as proposed by Fredkin and Koehler.
  """

  def __init__(self, domain_name, rhs_form, solver = "LU", **kwargs):
    """
    *Arguments*
        domain_name (:class:`string`)
            Domain name of the region to solve.
        rhs_form (:class:`lambda`)
            Lambda that returns the RHS part of the weak form.
        solver (:class:`string`)
            Solver type for FEM systems (either "LU" or "CG")
    """

    #if not _found_bempp: TODO log warning
    self.domain_name = domain_name
    self.rhs_form    = rhs_form
    self._solver     = solver

    default_options = {
      'loglevel': 'default'
    }
    self._options = dict(default_options.items() + kwargs.items())

    # caches
    self._assemble_cache       = Cache()
    self._assemble_cache_u1    = Cache()
    self._assemble_cache_u2_bc = Cache()
    self._assemble_cache_u2    = Cache()

  def calculate_u1(self, state, rhs_coeffs):
    cache = self._assemble_cache_u1
    if cache.requires_update(state):
      # form setup
      V = state.FunctionSpace()
      u = TrialFunction(V)
      v = TestFunction(V)
      n = FacetNormal(state.mesh)

      # setup RHS coefficients
      cache.rhs_coeffs = []
      for coeff in rhs_coeffs:
        result = None
        if isinstance(coeff, Constant):
          # TODO there has be to be a more elegant way
          if coeff.rank() == 0: result = Constant(0.0)
          if coeff.rank() == 1: result = Constant((0.0, 0.0, 0.0))
        elif isinstance(coeff, Function):
          result = Function(coeff.function_space())

        if result == None: raise "Coefficient type not supported"
        cache.rhs_coeffs.append(result)

      a = inner(grad(u), grad(v)) * dx
      L = self.rhs_form(cache.rhs_coeffs, v, n)

      cache.w = Function(V)

      cache.A, cache.b = Matrix(), Vector()
      cache.assembler = SystemAssembler(a, L)
      cache.assembler.assemble(cache.A)

      if self._solver == "LU":
        cache.solver = LUSolver(cache.A, "mumps")
        cache.solver.parameters['reuse_factorization'] = True
        cache.solver.parameters['same_nonzero_pattern'] = True
        cache.solver.parameters['symmetric'] = True
      elif self._solver == "CG":
        null_vec = Vector(cache.w.vector())
        V.dofmap().set(null_vec, 1.0)
        null_vec *= 1.0/null_vec.norm("l2")
        cache.null_space = VectorSpaceBasis([null_vec])

        cache.solver = KrylovSolver(cache.A, "cg", "amg")
        cache.solver.set_nullspace(cache.null_space)
      else:
        raise ValueError("Solver type '%s' not supported." % self._solver)

    # assign RHS coefficients
    for source, target in zip(rhs_coeffs, cache.rhs_coeffs):
      target.assign(source)

    cache.assembler.assemble(cache.b)
    if self._solver == "CG":
      cache.null_space.orthogonalize(cache.b)
    cache.solver.solve(cache.w.vector(), cache.b)

    return cache.w

  def calculate_u2_bc(self, state, u1):
    cache = self._assemble_cache_u2_bc
    if cache.requires_update(state):
      cache.boundary_mesh = BoundaryMesh(u1.function_space().mesh(), "exterior", False)
      cache.bm_coords     = cache.boundary_mesh.coordinates()
      cache.bm_cells      = cache.boundary_mesh.cells()
      cache.bm_nodes      = cache.boundary_mesh.entity_map(0).array().astype(np.int64)
      cache.mapping       = np.array(vertex_to_dof_map(u1.function_space())).take(cache.bm_nodes)

      # import mesh from Fenics
      grid = createGridFactory().createGridFromConnectivityArrays('triangular', cache.bm_coords.transpose(), cache.bm_cells.transpose())

      # set quadrature strategies
      accuracyOptions = createAccuracyOptions()
      accuracyOptions.doubleRegular.setRelativeQuadratureOrder(5)
      accuracyOptions.doubleSingular.setRelativeQuadratureOrder(5)
      accuracyOptions.singleRegular.setRelativeQuadratureOrder(5)
      quadStrategy = createNumericalQuadratureStrategy("float64", "float64", accuracyOptions)

      # Create assembly context and initialize spaces 
      assemblyOptions = createAssemblyOptions()
      assemblyOptions.setVerbosityLevel(self._options['loglevel'])
      cache.context = createContext(quadStrategy, assemblyOptions)
      cache.pwiseLinears = createPiecewiseLinearContinuousScalarSpace(cache.context, grid)

      # Construct elementary operators
      cache.dlpOp   = createLaplace3dDoubleLayerBoundaryOperator(cache.context, cache.pwiseLinears, cache.pwiseLinears, cache.pwiseLinears).weakForm()
      cache.invIdOp = pseudoinverse(createIdentityOperator(cache.context, cache.pwiseLinears, cache.pwiseLinears, cache.pwiseLinears)).weakForm()

    # Construct the grid function representing the (input) Dirichlet data
    u1_BEM = createGridFunction(cache.context, cache.pwiseLinears, cache.pwiseLinears, coefficients=u1.vector()[cache.mapping])
    u2_BEM = cache.invIdOp * (cache.dlpOp * u1_BEM.coefficients())

    # set u2 dirichlet boundary conditions
    u2_BC = Function(state.FunctionSpace())
    u2_BC.vector()[cache.mapping] = u2_BEM

    return DirichletBC(state.FunctionSpace(), u2_BC, DomainBoundary())

  def calculate_u2(self, state, bc):
    cache = self._assemble_cache_u2
    if cache.requires_update(state):
      V = state.FunctionSpace()
      u = TrialFunction(V)
      v = TestFunction(V)

      # define u2 dirichlet-problem 
      a = inner(grad(u), grad(v)) * dx
      L = Constant(0.0) * v * dx

      cache.A = assemble(a)
      cache.b = assemble(L)

      cache.u2 = Function(V)

      if self._solver == "LU":
        bc.apply(cache.A)
        cache.solver = LUSolver(cache.A, "mumps")
        cache.solver.parameters['reuse_factorization'] = True
        cache.solver.parameters['same_nonzero_pattern'] = True
      elif self._solver == "CG":
        cache.solver = KrylovSolver(cache.A, "cg", "amg")
      else:
        raise ValueError("Solver type '%s' not supported." % self._solver)

    if self._solver == "LU":
      bc.apply(cache.b)
      cache.solver.solve(cache.u2.vector(), cache.b)
    elif self._solver == "CG":
      bc.apply(cache.A, cache.b)
      cache.solver.solve(cache.A, cache.u2.vector(), cache.b)

    return cache.u2

  def calculate(self, state, *args):
    """
    Solve the open boundary problem for a given state.

    *Arguments*
        state (:class:`State`)
            The simulation state
        *args
            Additional coefficients used in the RHS form.
    """
    cache = self._assemble_cache
    if cache.requires_update(state):
      cache.state_mask = state.mask(self.domain_name)

    # prepare RHS coefficients
    rhs_coeffs = map(lambda coeff: cache.state_mask.cut(coeff), args)

    with Timer("u1 FEM"): u1 = self.calculate_u1(cache.state_mask, rhs_coeffs)
    with Timer("u2 BEM"): bc = self.calculate_u2_bc(cache.state_mask, u1)
    with Timer("u2 FEM"): u2 = self.calculate_u2(cache.state_mask, bc)

    result = Function(cache.state_mask.FunctionSpace(), - 0.5 * u1.vector() - u2.vector())

    return cache.state_mask.expand(result)
