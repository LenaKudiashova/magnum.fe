from __future__ import absolute_import 
from dolfin import *
from magnumfe import Mesher, MetricMatrix, WrappedMesh

from PyTrilinos import Epetra, AztecOO, TriUtils, ML

import time

__all__ = ["DemagField"]

class DemagField:
  def __init__(self, mesh, **kwargs):
    self.mesh  = mesh
    self.order = kwargs.pop('order', 1)

    self._assemble_cache = None
    self._trilinos_cache = None

  ########################################
  # System matrix assembly
  ########################################
  def _assemble(self):
    if self._assemble_cache: return self._assemble_cache

    VS = FunctionSpace(self.mesh.with_shell, "Lagrange", self.order)
    VV = VectorFunctionSpace(self.mesh.with_shell, "Lagrange", self.order)
    VQ = TensorFunctionSpace(self.mesh.with_shell, "Quadrature", 5)

    v = TestFunction(VS)
    u = TrialFunction(VS)

    sample_size = self.mesh.data['sample_size']
    transformation_order = 1 if (self.order == 1) else 2
    gx = MetricMatrix.create_for_cube(sample_size, 0, transformation_order)
    gy = MetricMatrix.create_for_cube(sample_size, 1, transformation_order)
    gz = MetricMatrix.create_for_cube(sample_size, 2, transformation_order)

    # Interpolate all entities
    Igx = interpolate(gx, VQ)
    Igy = interpolate(gy, VQ)
    Igz = interpolate(gz, VQ)

    # setup system
    a = Dx(v, i) * Dx(u, i)            * dx(0) + \
        Dx(v, i) * Dx(u, i)            * dx(1) + \
        Dx(v, i) * Igx[i,j] * Dx(u, j) * dx(2) + \
        Dx(v, i) * Igy[i,j] * Dx(u, j) * dx(3) + \
        Dx(v, i) * Igz[i,j] * Dx(u, j) * dx(4)

    bc = DirichletBC(VS, Constant(0.0), DomainBoundary())

    A, An = symmetric_assemble(a, bc)

    u = Function(VS)

    solver = KrylovSolver(A, "cg", "amg")
    solver.parameters["nonzero_initial_guess"] = True

    self._assemble_cache = (solver, An, bc, v, u)
    return self._assemble_cache

  ########################################
  # FEniCS standard calcute method
  ########################################
  def calculate(self, m):
    solver, An, bc, v, u = self._assemble()

    t0 = time.time()

    Im  = self.mesh.expand(m)
    L = inner(grad(v), Im) * dx(0)
    b = assemble(L)
    bc.apply(b)
    b = b - An*b

    solver.solve(u.vector(), b)
    print "Demag: %s" % (time.time() - t0)

    return self.mesh.cut(u)

  ########################################
  # Static mesh creation method
  ########################################
  @staticmethod
  def create_mesh(*args, **kwargs):
    mesher = Mesher()

    if isinstance(args[0], str):
      mesher.read_file(args[0])
    elif isinstance(args[0], (list, tuple)) and isinstance(args[1], (list, tuple)):
      mesher.create_cuboid(args[0], args[1])
    else:
      error("Arguments not supported.")

    d = kwargs.pop('d', 1)
    mesher.create_shell(d, **kwargs)

    mesh    = mesher.mesh()

    return WrappedMesh.create(mesh, 0, {'sample_size': mesher.get_sample_size()})
