from __future__ import absolute_import 
from dolfin import *
from magnumfe import Mesher, MetricMatrix, WrappedMesh

from PyTrilinos import Epetra, AztecOO, TriUtils, ML

import time

__all__ = ["DemagField"]

class DemagField:
  def __init__(self, mesh, **kwargs):
    self.mesh  = mesh
    self.order = kwargs.pop('order', 1)

    self._assemble_cache = None
    self._trilinos_cache = None

  ########################################
  # System matrix assembly
  ########################################
  def _assemble(self):
    if self._assemble_cache: return self._assemble_cache

    VS = FunctionSpace(self.mesh.with_shell, "Lagrange", self.order)
    VV = VectorFunctionSpace(self.mesh.with_shell, "Lagrange", self.order)
    VQ = TensorFunctionSpace(self.mesh.with_shell, "Quadrature", 5)

    v = TestFunction(VS)
    u = TrialFunction(VS)

    sample_size = self.mesh.data['sample_size']
    transformation_order = 1 if (self.order == 1) else 2
    gx = MetricMatrix.create_for_cube(sample_size, 0, transformation_order)
    gy = MetricMatrix.create_for_cube(sample_size, 1, transformation_order)
    gz = MetricMatrix.create_for_cube(sample_size, 2, transformation_order)

    # Interpolate all entities
    Igx = interpolate(gx, VQ)
    Igy = interpolate(gy, VQ)
    Igz = interpolate(gz, VQ)

    # setup system
    a = Dx(v, i) * Dx(u, i)            * dx(0) + \
        Dx(v, i) * Dx(u, i)            * dx(1) + \
        Dx(v, i) * Igx[i,j] * Dx(u, j) * dx(2) + \
        Dx(v, i) * Igy[i,j] * Dx(u, j) * dx(3) + \
        Dx(v, i) * Igz[i,j] * Dx(u, j) * dx(4)

    bc = DirichletBC(VS, Constant(0.0), DomainBoundary())

    A, An = symmetric_assemble(a, bc)

    u = Function(VS)

    self._assemble_cache = (A, An, bc, v, u)
    return self._assemble_cache

  ########################################
  # FEniCS standard calcute method
  ########################################
  def calculate(self, m):
    A, An, bc, v, u = self._assemble()

    t0 = time.time()

    Im  = self.mesh.expand(m)
    L = inner(grad(v), Im) * dx(0)
    b = assemble(L)
    bc.apply(b)
    b = b - An*b

    solve(A, u.vector(), b, "cg", "amg")
    print "Demag: %s" % (time.time() - t0)

    return self.mesh.cut(u)

  ########################################
  # Trilinos specific stuff
  ########################################
  def _get_amg_prec(self, A):
    ML_param = {"max levels"        : 3,
                "output"            : 10,
                "smoother: type"    : "ML symmetric Gauss-Seidel",
                "aggregation: type" : "Uncoupled",
                "ML validate parameter list" : False
    }

    prec = ML.MultiLevelPreconditioner(A, False)
    prec.SetParameterList(ML_param)
    prec.ComputePreconditioner()

    return prec

  def _get_ilu_prec(self, A):
    factory = IFPACK.Factory()
    prec = factory.Create("ILU", A)
    IFPACKList = {
        "fact: level-of-fill": ("int", "5")
        }
    prec.SetParameters(IFPACKList)
    prec.Initialize()
    prec.Compute()

    return prec

  def _init_trilinos(self, A, prec="ilu"):
    if self._trilinos_cache: return self._trilinos_cache

    A_epetra = down_cast(A).mat()

    prec = None
    if (prec == "ilu"): prec = self._get_ilu_prec(A_epetra)
    if (prec == "amg"): prec = self._get_amg_prec(A_epetra)

    self._trilinos_cache = (prec)
    return self._trilinos_cache

  def calculate_trilinos(self, m):
    A, An, bc, v, u = self._assemble()
    prec = self._init_trilinos(A)

    t0 = time.time()

    # calculate rhs
    Im  = self.mesh.expand(m)
    L = inner(grad(v), Im) * dx(0)
    b = assemble(L)
    bc.apply(b)
    b = b - An*b

    A_epetra = down_cast(A).mat()
    b_epetra = down_cast(b).vec()
    U_epetra = down_cast(u.vector()).vec()

    # Create solver and solve system
    solver = AztecOO.AztecOO(A_epetra, U_epetra, b_epetra)
    solver.SetPrecOperator(prec)
    solver.SetAztecOption(AztecOO.AZ_solver, AztecOO.AZ_cg)
    solver.SetAztecOption(AztecOO.AZ_output, 0)
    #solver.Iterate(MaxIters=1550, Tolerance=1e-5)
    solver.Iterate(1550, 1e-7)

    print "Demag: %s" % (time.time() - t0)

    return self.mesh.cut(u)

  ########################################
  # Static mesh creation method
  ########################################
  @staticmethod
  def create_mesh(*args, **kwargs):
    mesher = Mesher()

    if isinstance(args[0], str):
      mesher.read_file(args[0])
    elif isinstance(args[0], (list, tuple)) and isinstance(args[1], (list, tuple)):
      mesher.create_cuboid(args[0], args[1])
    else:
      error("Arguments not supported.")

    d = kwargs.pop('d', 1)
    mesher.create_shell(d, **kwargs)

    mesh    = mesher.mesh()

    return WrappedMesh.create(mesh, 0, {'sample_size': mesher.get_sample_size()})
