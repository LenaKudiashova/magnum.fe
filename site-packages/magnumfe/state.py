# Copyright (C) 2011-2014 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2014-07-07

from __future__ import absolute_import 

import types

from dolfin import MeshFunction, Measure, FunctionSpace, VectorFunctionSpace, \
    Expression, Constant, interpolate, Constant, FunctionSpaceBase, assemble, \
    Function, interpolate

from magnumfe import Material, WrappedMesh

__all__ = ["State"]

class CellExpr(Expression):
  def __init__(self, attr, domains, materials):
    self._attr      = attr
    self._domains   = domains
    self._materials = materials

  def eval_cell(self, result, x, cell):
    try:
      material = self._materials[self._domains[cell.index]]
    except KeyError:
      material = Material()

    try:
      result[0] = getattr(material, self._attr)
    except AttributeError:
      result[0] = 0.0

class VectorCellExpr(Expression):
  def __init__(self, attr, domains, materials):
    self._attr      = attr
    self._domains   = domains
    self._materials = materials

  def eval_cell(self, result, x, cell):
    try:
      material = self._materials[self._domains[cell.index]]
    except KeyError:
      material = Material()

    try:
      values = getattr(material, self._attr)
      result[0] = values[0]
      result[1] = values[1]
      result[2] = values[2]
    except (AttributeError, TypeError):
      result[0] = 0.0
      result[1] = 0.0
      result[2] = 0.0
  def value_shape(self):
    return (3,)

class HomogeneousMaterial(object):
  def __init__(self, material):
    object.__setattr__(self, '_material', material)

  def __setattr__(self, attr, value):
    return setattr(self._material, attr, value)

  def __getattr__(self, attr):
    value = getattr(self._material, attr)

    if isinstance(value, list):
      value = tuple(value)

    return Constant(value)

class CompositeMaterial(object):
  def __init__(self, state):
    self._state = state
    self._cache = {}
    self._materials = {}

  def __setitem__(self, index, value):
    self._materials[index] = value
    self._cache = {}
    return value

  def __getitem__(self, index):
    return self._materials[index]

  def __delitem__(self, index):
    del self._materials[index]
    self._cache = {}

  def __getattr__(self, attr):
    if attr in self._cache:
      return self._cache[attr]

    materials = {}
    for domain in self._materials:
      material = self._materials[domain]
      ids = self._state.domain_ids(domain)
      for id in ids:
        materials[id] = material
    
    # scalar or vector parameter
    V    = None
    expr = None
    for domain in self._materials:
      material = self._materials[domain]
      try:
        value = getattr(material, attr)
        if isinstance(value, tuple) or isinstance(value, list):
          assert len(value) == 3
          V    = VectorFunctionSpace(self._state.mesh, 'DG', 0)
          expr = VectorCellExpr(attr, self._state.cell_domains, materials)
        else:
          V    = FunctionSpace(self._state.mesh, 'DG', 0)
          expr = CellExpr(attr, self._state.cell_domains, materials)
      except AttributeError:
        continue

    self._cache[attr] = interpolate(expr, V)
    return self._cache[attr]

def _crop(self, domain = "all"):
  mesh = self._state.wrapped_mesh_for(domain)
  return mesh.cut(self)

def _average(self, domain = "all"):
  volume = self._state.volume(domain)
  dx     = self._state.dx(domain)

  if self.rank() == 0:
    return assemble(self * dx) / volume
  elif self.rank() == 1:
    return tuple(map(lambda i: assemble(self[i] * dx) / volume, range(self.value_size())))
  else:
    raise Exception("Not supported")

class State(object):
  def __init__(self, mesh, celldomains = {'magnetic': 1, 'conducting': 1}, facetdomains = { }, material = None, **kwargs):
    self.mesh = mesh
    self.set_celldomains(celldomains)
    self.set_facetdomains(facetdomains)

    # TODO add args to set domains via mesh functions directly
    self.cell_domains  = MeshFunction('size_t', mesh, 3, mesh.domains())
    self.facet_domains = MeshFunction('size_t', mesh, 2, mesh.domains())

    self._dx = Measure('dx', mesh)[self.cell_domains]
    #self._dS = Measure('dS', mesh)[self.facet_domains]
    self._ds = Measure('ds', mesh)[self.facet_domains]

    self._VS = FunctionSpace(self.mesh, 'CG', 1)          # TODO lazy initialize
    self._VV = VectorFunctionSpace(self.mesh, 'CG', 1, 3) # TODO lazy initialize

    self.material = material or CompositeMaterial(self)

    self._wrapped_meshes = {}
    self._volumes        = {}

    for key, value in kwargs.iteritems():
      # XXX really interpolate every entry?
      # maybe it's useful to allow Constants/Expressions sometimes
      if isinstance(value, Expression) or isinstance(value, Constant):
        if value.rank() == 0:
          value = interpolate(value, self.FunctionSpace())
        elif value.rank() == 1:
          value = interpolate(value, self.VectorFunctionSpace())
        else:
          raise Exception("Not supported")

      value._state  = self
      value.crop    = types.MethodType(_crop, value)
      value.average = types.MethodType(_average, value)
      value.rename(key, value.label())

      setattr(self, key, value)

  def wrapped_mesh_for(self, domain):
    if not self._wrapped_meshes.has_key(domain):
      self._wrapped_meshes[domain] = WrappedMesh.create(self.mesh, self.domain_ids(domain))

    return self._wrapped_meshes[domain]

  def volume(self, domain):
    if not self._volumes.has_key(domain):
      self._volumes[domain] = assemble(Constant(1.0)*self.dx(domain))

    return self._volumes[domain]

  @property
  def material(self):
    return self._material

  @material.setter
  def material(self, value):
    if isinstance(value, Material):
      self._material = HomogeneousMaterial(value)
    else:
      self._material = value

  def set_celldomains(self, celldomains):
    self.celldomains = {}
    for material in celldomains:
      ids = celldomains[material]
      if isinstance(ids, int):  ids = (ids,)
      if isinstance(ids, list): ids = tuple(ids)
      self.celldomains[material] = ids

  def set_facetdomains(self, facetdomains):
    self.facetdomains = {}
    for material in facetdomains:
      ids = facetdomains[material]
      if isinstance(ids, int):  ids = (ids,)
      if isinstance(ids, list): ids = tuple(ids)
      self.facetdomains[material] = ids

  def domain_ids(self, domain, domaintype = 'cell'):
    if isinstance(domain, int):
      return [domain]

    domains = {
        'cell':  self.celldomains,
        'facet': self.facetdomains
      }[domaintype]

    if domain == 'all':
      ids = tuple()
      for material in domains:
        ids = ids + domains[material]
      return tuple(set(ids))
    elif domain[0] == '!':
      ids = set(self.domain_ids('all', domaintype))
      for id in self.domain_ids(domain[1:], domaintype):
        ids.remove(id)
      return tuple(ids)
    else:
      return domains[domain]

  def dx(self, domain = "all", dx = None):
    # return measure for whole mesh if no domains are defined
    if not self.mesh_has_domains(): return self._dx

    domain_ids = self.domain_ids(domain)
    if len(domain_ids) == 0: return None

    if dx == None: dx = self._dx

    measure = dx(domain_ids[0])
    for domain_id in domain_ids[1:]:
      measure += dx(domain_id)

    return measure
 
  def ds(self, domain = "all", ds = None):
    # return measure for whole mesh if no domains are defined
    if not self.mesh_has_domains(): return self._ds

    domain_ids = self.domain_ids(domain, 'facet')
    if len(domain_ids) == 0: return None

    if ds == None: ds = self._ds

    measure = ds(domain_ids[0])
    for domain_id in domain_ids[1:]:
      measure += ds(domain_id)

    return measure

  def mesh_has_domains(self):
    return self.mesh.domains().num_marked(3) != 0

  def interpolate(self, expressions):
    result = Function(self.FunctionSpace(rank = expressions.itervalues().next().rank()))
    result.vector().zero()
    for domain in expressions:
      wmesh = self.wrapped_mesh_for(domain)
      expression = expressions[domain]
      f = interpolate(expression, self.FunctionSpace(wmesh, expression.rank()))
      result.vector().axpy(1.0, wmesh.expand(f).vector())
    return result

  def VectorFunctionSpace(self, mesh = None):
    if mesh == None: return self._VV
    element = self._VS.ufl_element()
    return VectorFunctionSpace(mesh, element.family(), element.degree())

  def FunctionSpace(self, mesh = None, rank = 0):
    if rank == 0:
      if mesh == None: return self._VS
      element = self._VS.ufl_element()
      return FunctionSpace(mesh, element.family(), element.degree())
    elif rank == 1:
      return self.VectorFunctionSpace(mesh)
    else:
      raise Exception("Rank not supported.")
