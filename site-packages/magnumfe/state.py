# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-01-05

from __future__ import absolute_import 

import types
import collections

from dolfin import MeshFunction, Measure, FunctionSpace, VectorFunctionSpace, \
    Expression, Constant, interpolate, Constant, FunctionSpaceBase, assemble, \
    Function, interpolate, GenericFunction

from magnumfe import Material, WrappedMesh, DofAssembler, NormalizedVector

__all__ = ["State"]

class CellExpr(Expression):
  def __init__(self, attr, domains, materials):
    self._attr      = attr
    self._domains   = domains
    self._materials = materials

  def eval_cell(self, result, x, cell):
    try:
      material = self._materials[self._domains[cell.index]]
    except KeyError:
      material = Material()

    try:
      result[0] = getattr(material, self._attr)
    except AttributeError:
      result[0] = 0.0

class VectorCellExpr(Expression):
  def __init__(self, attr, domains, materials):
    self._attr      = attr
    self._domains   = domains
    self._materials = materials

  def eval_cell(self, result, x, cell):
    try:
      material = self._materials[self._domains[cell.index]]
    except KeyError:
      material = Material()

    try:
      values = getattr(material, self._attr)
      result[0] = values[0]
      result[1] = values[1]
      result[2] = values[2]
    except (AttributeError, TypeError):
      result[0] = 0.0
      result[1] = 0.0
      result[2] = 0.0
  def value_shape(self):
    return (3,)

class HomogeneousMaterial(object):
  def __init__(self, material):
    object.__setattr__(self, '_material', material)

  def __setattr__(self, attr, value):
    return setattr(self._material, attr, value)

  def __getattr__(self, attr):
    value = getattr(self._material, attr)

    if isinstance(value, list):
      value = tuple(value)

    return Constant(value)

class CompositeMaterial(object):
  def __init__(self, state):
    self._state = state
    self._cache = {}
    self._materials = {}

  def __setitem__(self, index, value):
    self._materials[index] = value
    self._cache = {}
    return value

  def __getitem__(self, index):
    return self._materials[index]

  def __delitem__(self, index):
    del self._materials[index]
    self._cache = {}

  def __getattr__(self, attr):
    if attr in self._cache:
      return self._cache[attr]

    materials = {}
    for domain in self._materials:
      material = self._materials[domain]
      ids = self._state.domain_ids(domain)
      for id in ids:
        materials[id] = material
    
    # scalar or vector parameter
    V    = None
    expr = None
    for domain in self._materials:
      material = self._materials[domain]
      try:
        value = getattr(material, attr)
        if isinstance(value, tuple) or isinstance(value, list):
          assert len(value) == 3
          V    = VectorFunctionSpace(self._state.mesh, 'DG', 0)
          expr = VectorCellExpr(attr, self._state.cell_domains, materials)
        else:
          V    = FunctionSpace(self._state.mesh, 'DG', 0)
          expr = CellExpr(attr, self._state.cell_domains, materials)
      except AttributeError:
        continue

    self._cache[attr] = interpolate(expr, V)
    return self._cache[attr]

def _crop(self, domain = "all"):
  mesh = self._state.wrapped_mesh_for(domain)
  return mesh.cut(self)

def _average(self, domain = "all"):
  volume = self._state.volume(domain)
  dx     = self._state.dx(domain)

  if self.rank() == 0:
    return assemble(self * dx) / volume
  elif self.rank() == 1:
    return tuple(map(lambda i: assemble(self[i] * dx) / volume, range(self.value_size())))
  else:
    raise Exception("Not supported")

def _normalize(self):
  self.assign(Function(
    self.function_space(),
    DofAssembler.assemble(NormalizedVector(self.function_space(), self))
  ))

class State(object):
  def __init__(self, mesh, celldomains = {'magnetic': 1, 'conducting': 1}, facetdomains = { }, material = None, scale = 1.0, **kwargs):
    """
    This class holds the complete state of the simulation and provides some
    convenience wrappers for the handling of multiple domains.

    *Example*
      .. code-block:: python

        state = State(mesh,
          celldomains = {'magnetic': (1,3), 'conducting': 2, 'iron': 1, 'cobalt': 3}
          m = Expression(...)
        )

        # Set materials for different regions
        state.material['iron']       = Material(...)
        state.material['cobalt']     = Material(...)
        state.material['conducting'] = Material(...)

        # Use integration measures with named domains
        assemble(Constant(1.0) * state.dx('all'))       # All named domains
        assemble(Constant(1.0) * state.dx('magnetic'))  # Magnetic region
        assemble(Constant(1.0) * state.dx('!magnetic')) # Nonmagnetic region
        assemble(Constant(1.0) * state.dx(1))           # Region by ID

        # Compute average of magnetization m
        state.m.avg()       # Over whole space
        state.m.avg('iron') # Over iron region

        # Crop magnetization to subdomain and save as PVD
        f = File("m_iron.pvd")
        f << state.m.crop('iron')

        # Normalize the magnetization
        state.m.normalize()

    *Arguments*
      mesh (:class:`dolfin.Mesh`)
        The mesh including all subdomains as :class:`dolfin.MeshDomains`
      celldomains (:class:`dict`)
        naming of the cell subdomains, at least the subdomains 'magnetic' and 'conducting' should be defined.
      facetdomains (:class:`dict`)
        naming of the facet subdomains
      material (:class:`Material`)
        the material of the sample. If material differs from subdomain to subdomain, use material setters instead.
      scale (:class:`float`)
        the spatial scaling of the mesh. Use 1e-9 if you use nanometers as length measure.
      **kwargs (:class:`dict`)
        add any state variables like magnetization (m) or spin diffusion (s).
        Expressions are automatically interpolated on the corresponding discrete spaces.
        
    """

    self.mesh  = mesh
    self.scale = scale
    self.t = 0.0
    self.set_celldomains(celldomains)
    self.set_facetdomains(facetdomains)

    # TODO add args to set domains via mesh functions directly
    self.cell_domains  = MeshFunction('size_t', mesh, 3, mesh.domains())
    self.facet_domains = MeshFunction('size_t', mesh, 2, mesh.domains())

    self._dx = Measure('dx', mesh)[self.cell_domains]
    self._ds = Measure('ds', mesh)[self.facet_domains]
    self._dS = Measure('dS', mesh)[self.facet_domains]

    self._VS = FunctionSpace(self.mesh, 'CG', 1)          # TODO lazy initialize
    self._VV = VectorFunctionSpace(self.mesh, 'CG', 1, 3) # TODO lazy initialize

    self.material = material or CompositeMaterial(self)

    self._wrapped_meshes = {}
    self._volumes        = {}

    for key, value in kwargs.iteritems():
      setattr(self, key, value)

  def __setattr__(self, name, value):
    # XXX Really interpolate every expression/constant?
    if isinstance(value, Expression) or isinstance(value, Constant):
      if value.rank() == 0:
        value = interpolate(value, self.FunctionSpace())
      elif value.rank() == 1:
        value = interpolate(value, self.VectorFunctionSpace())
      else:
        raise Exception("Not supported")

    if isinstance(value, GenericFunction):
      value._state    = self
      value.crop      = types.MethodType(_crop, value)
      value.average   = types.MethodType(_average, value)
      value.normalize = types.MethodType(_normalize, value)
      value.rename(name, value.label())

    super(State, self).__setattr__(name, value)

  def wrapped_mesh_for(self, domain):
    """
    Creates a :class:`WrappedMesh` object for a certain domain. This can be
    used to crop certain state values like the magnetization to a region of
    interest.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        domain identifier (either string or id)

    *Returns*
      :class:`WrappedMesh`
        the wrapped mesh
    """
    if not self._wrapped_meshes.has_key(domain):
      self._wrapped_meshes[domain] = WrappedMesh.create(self.mesh, self.domain_ids(domain))

    return self._wrapped_meshes[domain]

  def volume(self, domain):
    """
    Computes the volume of a certain domain.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        domain identifier (either string or id)

    *Returns*
      :class:`float`
        the volume of the region
    """
    if not self._volumes.has_key(domain):
      self._volumes[domain] = assemble(Constant(1.0)*self.dx(domain))

    return self._volumes[domain]

  @property
  def material(self):
    return self._material

  @material.setter
  def material(self, value):
    if isinstance(value, Material):
      self._material = HomogeneousMaterial(value)
    else:
      self._material = value

  def set_celldomains(self, celldomains):
    self.celldomains = {}
    for material in celldomains:
      ids = celldomains[material]
      if isinstance(ids, int):  ids = (ids,)
      if isinstance(ids, list): ids = tuple(ids)
      self.celldomains[material] = ids

  def set_facetdomains(self, facetdomains):
    self.facetdomains = {}
    for material in facetdomains:
      ids = facetdomains[material]
      if isinstance(ids, int):  ids = (ids,)
      if isinstance(ids, list): ids = tuple(ids)
      self.facetdomains[material] = ids

  def domain_ids(self, domain, domaintype = 'cell'):
    """
    Get the domain IDs for a named domain.

    *Arguments*
      domain (:class:`string`/ :class:`int`)
        name or ID of domain
      domaintype (:class:`string`)
        domain type, (cell, facet)

    *Returns*
      :class:`[int]`
        List of domain IDs
    """
    if isinstance(domain, int):
      return [domain]

    domains = {
        'cell':  self.celldomains,
        'facet': self.facetdomains
      }[domaintype]

    if domain == 'all':
      ids = tuple()
      for material in domains:
        ids = ids + domains[material]
      return tuple(set(ids))
    elif domain[0] == '!':
      ids = set(self.domain_ids('all', domaintype))
      for id in self.domain_ids(domain[1:], domaintype):
        ids.remove(id)
      return tuple(ids)
    else:
      return domains[domain]

  def dx(self, domain = "all", dx = None):
    """
    Convenience wrapper for integral-cell measure. If the mesh does not contain
    any cell domains, the measure for the whole mesh is returned.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        name or ID of domain
      dx (:class:`dolfin:Measure`)
        alternative measure

    *Returns*
      :class:`dolfin:Measure`
        the measure

    *Example*
      .. code-block:: python

        # Compute volume of magnetic domain
        assemble(Constant(1.0) * state.dx('magnetic'))

        # Compute volume of domain with ID 3
        assemble(Constant(1.0) * state.dx(3))
    """
    # return measure for whole mesh if no domains are defined
    if not self.mesh_has_domains(): return self._dx

    domain_ids = self.domain_ids(domain)
    if len(domain_ids) == 0: return None

    if dx == None: dx = self._dx

    measure = dx(domain_ids[0])
    for domain_id in domain_ids[1:]:
      measure += dx(domain_id)

    return measure
 
  def ds(self, domain = "all", ds = None):
    """
    Convenience wrapper for integral-facet measure. If the mesh does not
    contain any cell domains, the measure for the whole mesh is returned.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        name or ID of domain
      ds (:class:`dolfin:Measure`)
        alternative measure

    *Returns*
      :class:`dolfin:Measure`
        the measure
    """
    # return measure for whole mesh if no domains are defined
    if not self.mesh_has_domains(): return self._ds

    domain_ids = self.domain_ids(domain, 'facet')
    if len(domain_ids) == 0: return None

    if ds == None: ds = self._ds

    measure = ds(domain_ids[0])
    for domain_id in domain_ids[1:]:
      measure += ds(domain_id)

    return measure

  def dS(self, domain = "all", dS = None):
    """
    Convenience wrapper for integral-interior-facet measure. If the mesh does
    not contain any cell domains, the measure for the whole mesh is returned.

    *Arguments*
      domain (:class:`string` / :class:`int`)
        name or ID of domain
      dS (:class:`dolfin:Measure`)
        alternative measure

    *Returns*
      :class:`dolfin:Measure`
        the measure
    """
    if dS == None:
      return self.ds(domain, self._dS)
    else:
      return self.ds(domain, dS)

  def mesh_has_domains(self):
    """
    Returns True if mesh contains cell-domain data.

    *Returns*
      :class:`bool`
        True if mesh contains cell-domain data
    """
    return self.mesh.domains().num_marked(3) != 0

  def interpolate(self, expressions):
    """
    Interpolates a collection of expressions, each defined for a specific domain,
    on a suitable function space.

    *Arguments*
      expressions (:class:`dict`)
        Expressions to be interpolated.

    *Returns*
      :class:`dolfin.Function`
        Interpolated function

    *Example*
      .. code-block:: python

        f = state.interpolate({
          'magnetic':  Constant((1.0, 0.0, 0.0)),
          '!magnetic': Constant((0.0, 1.0, 0.0))
        })
    """
    result = Function(self.FunctionSpace(rank = expressions.itervalues().next().rank()))
    result.vector().zero()
    for domain in expressions:
      wmesh = self.wrapped_mesh_for(domain)
      expression = expressions[domain]
      f = interpolate(expression, self.FunctionSpace(wmesh, expression.rank()))
      result.vector().axpy(1.0, wmesh.expand(f).vector())
    return result

  def step(self, integrators, dt):
    """
    Calls the step method on every integrator and increases :code:`t`.

    *Arguments*
      integrators (:class:`list` or :class:`Integrator`)
        Integrator on which the step method is called.
        Can be either a list of integrators or a single integrator.
    """
    if not isinstance(integrators, collections.Iterable):
      integrators = [integrators]

    for integrator in integrators:
      integrator.step(self, dt)

    self.t += dt

  def VectorFunctionSpace(self, mesh = None):
    """
    Returns the vector-function space for a mesh.

    *Arguments*
      mesh (:class:`dolfin.Mesh`)
        the mesh, defaults to mesh of the state if set to :code:`None`

    *Returns*
      :class:`dolfin.FunctionSpace`
        the function space
    """
    if mesh == None: return self._VV
    element = self._VS.ufl_element()
    return VectorFunctionSpace(mesh, element.family(), element.degree())

  def FunctionSpace(self, mesh = None, rank = 0):
    """
    Returns a function space for a mesh.

    *Arguments*
      mesh (:class:`dolfin.Mesh`)
        the mesh, defaults to mesh of the state if set to :code:`None`
      rank (:class:`int`)
        the rank of the function space (0 for scalar space, 1 for vector space)

    *Returns*
      :class:`dolfin.FunctionSpace`
        the function space
    """
    if rank == 0:
      if mesh == None: return self._VS
      element = self._VS.ufl_element()
      return FunctionSpace(mesh, element.family(), element.degree())
    elif rank == 1:
      return self.VectorFunctionSpace(mesh)
    else:
      raise Exception("Rank not supported.")
