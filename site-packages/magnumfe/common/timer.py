# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-01-21

from __future__ import absolute_import 

import time
from collections import OrderedDict
from magnumfe.lib.tabulate import tabulate

__all__ = ["Timer"]

class Timer(object):
  _timers  = OrderedDict()
  _current = ''
  _options = {
    'active': False,
    'skip': 0
  }

  def __init__(self, name):
    r"""
    Utility class that supports basic timing/profiling features. Each timer is
    initialized with a unique name. Each call to the body is timed and counted.
    Results can be printed with by calling :code:`print_report()`.

    *Example*
      .. code-block:: python

        Timer.enable()

        x = 0.0
        for i in range(10):
          with Timer("Outer Function"):
            for j in range(10):
              with Timer("Inner Function"):
                x += 1.0

        Timer.print_report()

      results in:

      .. code-block:: none

        ================================================
        TIMER REPORT
        ================================================
        Operation           No of calls    Avg time [ms]
        ----------------  -------------  ---------------
        Outer Function               10       0.022912
          Inner Function            100       0.00054121
        ================================================
    """
    if not Timer._options['active']: return

    self.t = 0.0
    self._fullname = Timer._current + '###' + name
    if self._fullname in self._timers:
      self._data= Timer._timers[self._fullname]
    else:
      self._data = {
        'name': name,
        'calls': 0,
        'total_time': 0.0,
        'parent': Timer._current
      }
      Timer._timers[self._fullname] = self._data

  def __enter__(self):
    if not Timer._options['active']: return self

    Timer._current = self._fullname
    self._data['start'] = time.time()
    return self

  def __exit__(self, e_typ, e_val, trcbak):
    if all((e_typ, e_val, trcbak)):
      raise e_typ, e_val, trcbak

    if not Timer._options['active']: return self

    if Timer._options['skip'] <= self._data['calls']:
      self.t = time.time() - self._data['start']
      self._data['total_time'] += self.t
    self._data['calls'] += 1
    Timer._current = self._data['parent']
    return self

  @staticmethod
  def print_report():
    """
    Print the timing report.
    """
    def get_entries(parent = '', indent = ''):
      result = []

      for entry in filter(lambda x: x[1]['parent'] == parent, Timer._timers.items()):
        timed_calls = entry[1]['calls'] - Timer._options['skip']
        if timed_calls == 0:
          t_avg = "-"
        else:
          t_avg = (entry[1]['total_time'] / timed_calls) * 1000

        result.append([indent + entry[1]['name'], entry[1]['calls'], t_avg])
        result += get_entries(entry[0], indent + '  ')

      return result

    entries = get_entries()
    table = tabulate(entries, ["Operation", "No of calls", "Avg time [ms]"])
    width = len(table.split("\n")[1])
    print ""
    print "=" * width
    print "TIMER REPORT"
    print "=" * width
    print table
    print "=" * width
    print ""

  @staticmethod
  def reset():
    """
    Reset all timers.
    """
    Timer._timers  = {}
    Timer._current = None

  @staticmethod
  def configure(**kwargs):
    """
    Configure the timer.

    *Arguments*
      active :class:`bool`
        Flag the activates/deactived all timers.
      skip :class:`int`
        Skip the timing of the first x calls to every timer. The calls are
        still counted, but not considered in the average execution time.
    """
    for (key, value) in kwargs.items():
      if key.lower() in Timer._options:
        Timer._options[key.lower()] = value
      else:
        raise ValueError("Option '%s' is not supported by Timer" % key)

  @staticmethod
  def disable():
    """
    Disable all timers.
    """
    Timer.configure(active = False)

  @staticmethod
  def enable(**kwargs):
    """
    Enable all timers. Takes all options that are accepted by :code:`configure`.
    """
    Timer.configure(active = True, **kwargs)
