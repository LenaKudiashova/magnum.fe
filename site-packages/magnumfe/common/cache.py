# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-02-16

from __future__ import absolute_import 

__all__ = ["Cache"]

class Cache(object):
  def __init__(self, *keys, **kwargs):
    """
    Simple cache class that is aware of changes in the state class.

    *Arguments*
      *keys ([:class:`string`])
        Names of state attributes to be monitored.
      **kwargs
        Any attributes to be attached to the cache object.
    *Example*
      .. code-block:: python

        # Initialize cache object that tracks changes in the m and t
        # attribute of the state class.
        cache = Cache("t", "m")

        # Check for cache hit. In case of cache miss the following
        # block is expected to update the cache. The hash keys of the
        # current state are saved.
        if cache.requires_update(state):
          cache.some_var = expensive_operation(state.t, state.m)

        if cache.requires_update(state):
          # Won't execute since cache is up to date
    """
    self._uuid = None
    self._keys = keys

    for key, val in kwargs.items():
      setattr(self, key, val)

  def requires_update(self, state):
    """
    Checks if cache is expired with resepect to the current state and
    saves the new state. Has to be followed by a block that updates
    the cache.

    *Arguments*
      state (:class:`State`)
        The current simulation state

    *Returns*
      :code:`True` if cache is expired, :code:`False` otherwise
    """
    if self._uuid != state.uuid(*self._keys):
      self._uuid = state.uuid(*self._keys)
      return True
    else:
      return False

  def wrap_func(self, func):
    """
    Builds a lambda from a given function that returns the function
    call along with the caching keys as required by the state class.

    *Arguments*
      func
        Function to be wrapped

    *Returns*
      Wrapped function
    """
    return lambda state: (func(state),) + tuple(self._keys)
