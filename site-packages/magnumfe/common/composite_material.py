# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-01-05

from __future__ import absolute_import 

import collections
import uuid

from dolfin import Expression, Constant, FunctionSpace, VectorFunctionSpace, \
    interpolate
from . import Material

__all__ = ["CompositeMaterial"]

class CellExpr(Expression):
  def __init__(self, attr, domains, base_material, materials):
    self._attr          = attr
    self._domains       = domains
    self._base_material = base_material
    self._materials     = materials

  def eval_cell(self, result, x, cell):
    try:
      material = self._materials[self._domains[cell.index]]
    except KeyError:
      material = self._base_material

    try:
      result[0] = getattr(material, self._attr)
    except AttributeError:
      result[0] = 0.0

class VectorCellExpr(Expression):
  def __init__(self, attr, domains, base_material, materials):
    self._attr          = attr
    self._domains       = domains
    self._base_material = base_material
    self._materials     = materials

  def eval_cell(self, result, x, cell):
    try:
      material = self._materials[self._domains[cell.index]]
    except KeyError:
      material = self._base_material

    try:
      values = getattr(material, self._attr)
      result[0] = values[0]
      result[1] = values[1]
      result[2] = values[2]
    except (AttributeError, TypeError):
      result[0] = 0.0
      result[1] = 0.0
      result[2] = 0.0
  def value_shape(self):
    return (3,)

class CompositeMaterial(object):
  def __init__(self, state, base_material = Material()):
    self._state         = state
    self._base_material = base_material
    self._cache         = {}
    self._materials     = collections.OrderedDict()
    self.uuid           = uuid.uuid4()

  def __setitem__(self, index, value):
    self._materials[index] = value
    self._cache = {}
    self.uuid = uuid.uuid4()
    return value

  def __getitem__(self, index):
    return self._materials[index]

  def __delitem__(self, index):
    del self._materials[index]
    self._cache = {}
    self.uuid = uuid.uuid4()

  def __setattr__(self, attr, value):
    if attr[0] == '_' or attr == 'uuid':
      return super(CompositeMaterial, self).__setattr__(attr, value)
    else:
      self._cache = {}
      self.uuid = uuid.uuid4()
      return setattr(self._base_material, attr, value)

  def __getattr__(self, attr):
    if attr in self._cache:
      return self._cache[attr]

    materials = {}
    for domain, material in self._materials.items():
      ids = self._state.domain_ids(domain)
      for id in ids:
        if materials.has_key(id):
          materials[id] = Material(materials[id], material)
        else:
          materials[id] = material
    
    # scalar or vector parameter
    V    = None
    expr = None
    if len(self._materials) == 0:
      self._cache[attr] = Constant(getattr(self._base_material, attr))
    else:
      for material in [self._base_material] + self._materials.values():
        try:
          value = getattr(material, attr)
          if isinstance(value, tuple) or isinstance(value, list):
            assert len(value) == 3
            V    = VectorFunctionSpace(self._state.mesh, 'DG', 0)
            expr = VectorCellExpr(attr, self._state.cell_domains, self._base_material, materials)
          else:
            V    = FunctionSpace(self._state.mesh, 'DG', 0)
            expr = CellExpr(attr, self._state.cell_domains, self._base_material, materials)
          break
        except AttributeError:
          continue

      self._cache[attr] = interpolate(expr, V)

    return self._cache[attr]

