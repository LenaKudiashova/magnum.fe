# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-06-10

from __future__ import absolute_import 

from dolfin import *

from . import LLGTerm
from magnumfe import WrappedMesh, Constants, Timer, Cache
import magnumfe.open_boundary as open_boundary

__all__ = ["DemagField"]

class DemagField(LLGTerm):

  def __init__(self, method = "Shell Transform", order = 1, solver = "LU", region = "magnetic", **kwargs):
    """
    Solves for the magnetic demagnetization field.

    *Arguments*
      method (:class:`str`)
        Method for the solution of the open-boundary problem.
        Possible Values are "Fredkin Koehler"/"FK" and "Shell Transform"/"ST"
      order (:class:`int`)
        The order of CG function used for the potential calculation.
        Currently only affects ST method.
      solver (:class:`str`)
        Solver type for FEM systems (either "LU" or "CG").
        Currently only affects FK method.
      region (:class:`str`)
        Name of the region considered for field computation
      aca_eps (:class:`float`)
        Accuracy of ACA algorithm. FK method only.
      loglevel (:class:`str`)
        Loglevel of Bem++ (low, default, high). FK method only.

    *Required fields*
      m
        Magnetization

    """
    self._assemble_cache = Cache("material")
    self._result_cache   = Cache("m")

    if method in ("ST", "Shell Transform"):
      self.solver = open_boundary.ShellTransform(
          lambda coeffs, v, state, measure: inner(grad(v), coeffs[0]) * state.dx(region, measure),
          order,
          **kwargs
        )

    elif method in ("FK", "Fredkin Koehler"):
      self.solver = open_boundary.FredkinKoehler(region,
          lambda coeffs, v, n: div(coeffs[0]) * v * dx - inner(coeffs[0], n) * v * ds,
          solver,
          **kwargs
        )
    else:
      raise ValueError("Method '%s' not available." % method)

  def form_rhs(self, state, w):
    return - state.material.ms * Constant(Constants.gamma) \
           * inner(grad(self.u(state)), w)

  def u(self, state):
    """
    Calculate the demagnetization-field potential u for a given simulation state

    *Arguments*
      state (:class:`State`)
        The simulation state
    """
    cache = self._result_cache
    if cache.requires_update(state):
      with Timer("Demag Potential"):
        cache.u = self.solver.calculate(state, state.m)
    return cache.u

  def field(self, state, x = None, lump = True):
    cache = self._assemble_cache
    if cache.requires_update(state):
      u = TrialFunction(state.FunctionSpace())
      w = TestFunction(state.VectorFunctionSpace())
      cache.A = assemble(- state.material.ms * inner(grad(u), w) * state.dx("magnetic"))

    with Timer("Demag Field"):
      return super(DemagField, self).field(state, x, lump, lambda state: cache.A*self.u(state).vector())

  @staticmethod
  def wrap_mesh(mesh):
    """
    Creates a WrappedMesh object from a mesh with cuboid shell as created by
    the magnum-msh script.

    *Arguments*
      mesh (:class:`dolfin.Mesh` or :class:`str`))
        The mesh including the cuboid shell (either mesh object or path to mesh file)
    """
    if type(mesh) is str:
      mesh = Mesh(mesh)
    return WrappedMesh.create(mesh, (1000, 1001, 1002, 1003), True)
