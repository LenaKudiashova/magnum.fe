# Copyright (C) 2011-2014 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# First added:  2012-11-30
# Last changed: 2012-11-30

from __future__ import absolute_import 

from dolfin import *

from magnumfe.dolfin import Mesher
from magnumfe.dolfin.expressions import MetricMatrix
from magnumfe.llg_terms import LLGTerm
from magnumfe.constants import Constants
from magnumfe import WrappedMesh

import time

__all__ = ["DemagField"]

class DemagField(LLGTerm):
  """
  This class defines methods for the micromagnetic stray-field computation.
  It uses cuboid transformation techniques of arbitrary order.
  """

  def __init__(self, sample_size, order = 1):
    """
    Create a _DemagField_ object for a given mesh.

    *Arguments*
        sample_size
            Tuple described the size of the sample. Usually this is taken from create_mesh.
        order
            The order of CG function used for the potential calculation.
    """

    self.sample_size = sample_size
    self.order       = order

  def form_term_rhs(self, state, w):
    return - state.material.ms * Constant(Constants.gamma) \
           * inner(grad(self.calculate_potential(state)), w)

  def calculate_potential(self, state):
    """
    Calculate the stray-field for a given simulation state

    *Arguments*
        state
            The simulation state
    """
    class Cache(): pass
    if not hasattr(self, '_assemble_cache'):
      cache = self._assemble_cache = Cache()

      if isinstance(state.mesh, WrappedMesh):
        mesh = state.mesh.with_shell
        cell_domains  = MeshFunction('size_t', mesh, 3, mesh.domains())
        measure = Measure('dx', mesh)[cell_domains]
        VV = VectorFunctionSpace(mesh, 'CG', 1)
      else:
        mesh = state.mesh
        measure = None
        VV = state.VectorFunctionSpace()
  
      VS = FunctionSpace(mesh, 'CG', self.order)
  
      v = TestFunction(VS)
      u = TrialFunction(VS)
  
      transformation_order = 1 if (self.order == 1) else 2
      gx = MetricMatrix.create_for_cube(self.sample_size, 0, transformation_order)
      gy = MetricMatrix.create_for_cube(self.sample_size, 1, transformation_order)
      gz = MetricMatrix.create_for_cube(self.sample_size, 2, transformation_order)
  
      cache.m = Function (VV)
  
      a = inner(grad(v), grad(u))      * state.dx('all', measure) \
        + inner(grad(v), grad(u))      * state.dx(1000, measure) \
        + inner(grad(v), gx * grad(u)) * state.dx(1001, measure) \
        + inner(grad(v), gy * grad(u)) * state.dx(1002, measure) \
        + inner(grad(v), gz * grad(u)) * state.dx(1003, measure)
  
      L = inner(grad(v), cache.m) * state.dx('magnetic', measure)
  
      cache.bc = DirichletBC(VS, Constant(0.0), DomainBoundary())
  
      cache.u = Function(VS)
  
      # set up assembler and solver objects
      cache.A, cache.b = Matrix(), Vector()
      cache.assembler = SystemAssembler(a, L, cache.bc)
      cache.assembler.assemble(cache.A)
  
      cache.solver = KrylovSolver(cache.A, "cg", "amg")
      cache.solver.parameters["nonzero_initial_guess"] = True
    else:
      # TODO perform sanity check
      cache = self._assemble_cache
  
    t0 = time.time()

    if isinstance(state.mesh, WrappedMesh):
      cache.m.assign(state.mesh.expand(state.m))
    else:
      cache.m.assign(state.m)

    cache.assembler.assemble(cache.b)
    cache.solver.solve(cache.u.vector(), cache.b)

    print "Demag: %s" % (time.time() - t0)

    if isinstance(state.mesh, WrappedMesh):
      return state.mesh.cut(cache.u)
    else:
      return cache.u

  @staticmethod
  def create_mesh(*args, **kwargs):
    """
    Creates a WrappedMesh suited for the application of the shell-
    transformation method. Either takes a filename as first argument
    to load the meshed sample or sizes and discretization of a cuboid
    sample.

    *Example*

        .. code-block:: python
            # load from file
            mesh = DemagField.create_mesh("sphere.msh", d=2, margin=0.1, n=(10, 10, 10))

            # create cuboid mesh of size 1.0 x 1.0 x 1.0
            mesh = DemagField.create_mesh((1.0, 1.0, 1.0), (10, 10, 10), d=2)

    *Arguments*
        d
            Number of shell layers.
        scale
            Scale factor used for mesh generation.
        margin
            Margin to the sample when loading sample mesh from a file.
        n
            Discretization of inner cuboid when loading sample mesh from a file.
    """
    # TODO allow creation of subdomains?
    mesher = Mesher()

    if isinstance(args[0], str):
      mesher.read_file(args[0])
    elif isinstance(args[0], (list, tuple)) and isinstance(args[1], (list, tuple)):
      mesher.create_cuboid(args[0], args[1])
    else:
      error("Arguments not supported.")

    d       = kwargs.pop('d', 1)
    scale   = kwargs.pop('scale', 1.0)
    domains = kwargs.pop('domains', {})

    mesher.create_shell(d, **kwargs)

    for domain_id in domains:
      mesher.create_celldomain(domains[domain_id], domain_id)

    mesh    = mesher.mesh(scale)

    return WrappedMesh.create(mesh, (1000, 1001, 1002, 1003), True), mesher.get_sample_size(scale = scale)
