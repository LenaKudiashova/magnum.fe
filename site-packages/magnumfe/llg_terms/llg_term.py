# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-02-17

from __future__ import absolute_import 

from dolfin import zero, TestFunction, TrialFunction, assemble, inner, solve, Function, Constant
from magnumfe import Constants, Timer

__all__ = ["LLGTerm"]

class LLGTerm(object):

  preconditionable = False

  def form_rhs(self, state, w):
    """
    Returns the right-hand-side contribution of the effective field
    for Alouges-type integration schemes.

    *Arguments*
      state (:class:`State`)
        The simulation state.
      w (:class:`dolfin.TestFunction`)
        The test function used in the Alouges integrator.

    *Returns*
      :class:`dolfin.Form`
        the form contribution for the RHS
    """
    return zero()

  def form_lhs(self, state, w, dt_v):
    """
    Returns the left-hand-side contribution of the effective field
    for Alouges-type integration schemes.

    *Arguments*
      state (:class:`State`)
        The simulation state.
      w (:class:`dolfin.TestFunction`)
        The test function used in the Alouges integrator.
      dt_v (:class:`dolfin.TrialFunction`)
        The trial function multiplied with the timestep and theta.

    *Returns*
      :class:`dolfin.Form`
        the form contribution for the LHS
    """
    return zero()

  def field(self, state, x = None, lump = True, rhs_func = None):
    """
    Returns the effective-field contribution for a given state.

    This method uses a projection method to retrieve the field from the
    RHS-form given by the :code:`form_rhs` method. It should be overriden
    for better performance.

    *Arguments*
      state (:class:`State`)
        the simulation state
      x (:class:`dolfin.Vector`)
        the vector to store the result or :code:`None`

    *Returns*
      :class:`dolfin.Function`
        the effective-field contribution
    """

    # TODO set particular solver
    # TODO use caching for mass matrix

    if rhs_func is None:
      w = TestFunction(state.VectorFunctionSpace())
      b = assemble(self.form_rhs(state, w) / Constant(Constants.gamma) * state.dx('magnetic'))
    else:
      b = rhs_func(state)

    # Optional mass lumping
    if x is None:
      result = Function(state.VectorFunctionSpace())
    else:
      result = Function(state.VectorFunctionSpace(), x)

    if lump:
      A = state.M_inv_diag('magnetic')
      A.mult(b, result.vector())
    else:
      w = TestFunction(state.VectorFunctionSpace())
      h = TrialFunction(state.VectorFunctionSpace())

      A = assemble(inner(w, h) * state.dx('magnetic'))
      solve(A, result.vector(), b)

    return result

  def prec_form(self, state, w):
    """
    Returns the m-dependent contribution to the preconditioner. Defaults to
    :code`form_rhs`.
    """
    return self.form_rhs(state, w)

  def prec_field(self, state, x = None, lump = False):
    """
    Returns the constant contribution to the preconditioner. Defaults to
    :code`field`.
    """
    return self.field(state, x, lump)
