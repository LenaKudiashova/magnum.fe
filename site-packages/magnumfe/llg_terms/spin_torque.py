# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-01-12

from __future__ import absolute_import 

from dolfin import *
from . import LLGTerm
from magnumfe import Constants

__all__ = ["SpinTorque"]

class SpinTorque(LLGTerm):

  def __init__(self):
    """
    This class represents the coupling of the magnetization with a spin polarized current.

    *Required material parameters*
      c
        Spin diffusion coupling constant
      TODO
    """
    pass

  def calculate_s(self, state):
    with Timer("Calculate S"):
      # regions
      Omega = 'conducting'
      omega = 'magnetic'

      # Functions Spaces ...
      V = state.FunctionSpace() * state.VectorFunctionSpace()
      u, s    = TrialFunctions(V)
      v, zeta = TestFunctions(V)

      C0         = state.material.C0
      D0x2       = state.material.D0 * Constant(2.0)
      beta       = state.material.beta
      beta_prime = state.material.beta_prime
      lambda_sf  = state.material.lambda_sf
      lambda_j   = state.material.lambda_j

      grad = lambda x: transpose(nabla_grad(x))
      n    = FacetNormal(state.mesh)

      # potential form
      a1 = Constant(2.0) * C0 * inner(grad(u), grad(v)) * state.dx(Omega)
      L1 = beta_prime * D0x2 * inner(transpose(grad(s)) * state.m, grad(v)) * state.dx(Omega)
      # TODO boundary terms
      # TODO BCs

      # Forms
      a2 = D0x2 / Constant(state.scale**2) * inner(grad(s), grad(zeta)) * state.dx(Omega)                                                          \
         - D0x2 / Constant(state.scale**2) * beta * beta_prime * inner(outer(state.m, transpose(grad(s)) * state.m), grad(zeta)) * state.dx(omega) \
         + D0x2 / lambda_sf**2 * inner(s, zeta) * state.dx(Omega)                                                                                  \
         + D0x2 / lambda_j**2 * inner(cross(s, state.m), zeta) * state.dx(omega)

      j = grad(u) * ... # TODO
      L2 = beta * Constant(Constants.mu_b / Constants.e / state.scale) * inner(outer(state.m, j), grad(zeta)) * state.dx(omega)   \
         - beta * Constant(Constants.mu_b / Constants.e / state.scale) * inner(state.m, zeta) * inner(j, n) * state.ds('outermagnet')

      A, b = assemble_system(a1 + a2, L1 + L2)

      result = Function(V)
      solve(A, result.vector(), b, "gmres", "ilu")
      solver = KrylovSolver(A, "gmres", "ilu")

      # TODO split result?

  def form_term_rhs(self, state, w):
    pass
