# Copyright (C) 2011-2014 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2014-06-12

from __future__ import absolute_import 

from dolfin import *

from magnumfe.dolfin import Mesher
from magnumfe.llg_terms import LLGTerm
from magnumfe.constants import Constants
from magnumfe import WrappedMesh
import magnumfe.open_boundary as open_boundary

__all__ = ["OerstedField"]

class OerstedField(LLGTerm):
  """
  Solves for the current induced Oersted field.
  """

  def __init__(self, method = "transform", sample_size = None, order = 1):
    """
    *Arguments*
        method
            Method for the solution of the open-boundary problem.
            Possible Values are "Fredkin Koehler"/"FK" and "Shell Transform"/"ST"
        sample_size
            Tuple described the size of the sample. Usually this is taken from create_mesh.
        order
            The order of CG function used for the potential calculation.
    """

    if method in ("ST", "Shell Transform"):
      if sample_size == None: raise "sample_size must be provided for shell-transform method"

      self.solver = open_boundary.ShellTransform(
          lambda rhs_func, v, state, measure: inner(grad(v), rhs_func) * state.dx('conducting', measure),
          lambda state: state.m,
          sample_size,
          order
        )
    elif method in ("FK", "Fredkin Koehler"):
      self.solver = open_boundary.FredkinKoehler(
          lambda rhs_func, v, n: div(rhs_func) * v * dx - inner(rhs_func, n) * v * ds,
          lambda state: state.m
        )
    else:
      raise "Method not available."

  def form_term_rhs(self, state, w):
    return - state.material.ms * Constant(Constants.gamma) \
           * inner(grad(self.calculate_potential(state)), w)

  def calculate_potential(self, state):
    """
    Calculate the stray-field for a given simulation state

    *Arguments*
        state
            The simulation state
    """
    return self.solver.calculate(state)
