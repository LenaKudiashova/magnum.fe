# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-06-10

from __future__ import absolute_import 

try:
  import scipy
  from block import *
  from block.iterative import BiCGStab, ConjGrad
  from block.dolfin_util import *
  from block.algebraic.petsc import ILU, InvDiag, collapse, LumpedInvDiag
  _found_cbcblock = True
except:
  # TODO log warning (also distinguish scipy and cbc.block)
  _found_cbcblock = False

from dolfin import *
from . import Integrator
from magnumfe import Constants, WrappedMesh, MetricMatrix, Timer, Cache

__all__ = ["LLGAlougesFullImplicit"]

class LLGAlougesFullImplicit(Integrator):

  def __init__(self, terms = [], sample_size = None, demag_order = 2):
    r"""

    Fully implicit solver for the Landau-Lifshitz-Gilbert equation including exchange field and demagnetization field according to Alouges [1].

    TODO write down math

    .. note:: This class requires CBC.Block and the PETSc linear-algebra backend.

    *Arguments*
        terms (:class:`LLGTerm`)
            Effective Field terms to be considered.
        demag_order (:class:`int`)
            The order of CG function used for the potential calculation.
    """

    if not has_linear_algebra_backend("PETSc"):
      raise Exception("LLGAlougesFullImplicit requires the PETSc backend to be active.")

    if not _found_cbcblock:
      raise Exception("LLGAlougesFullImplicit requires the CBC.Block library.")

    # parameters
    self.terms       = terms
    self.demag_order = demag_order

    self._assemble_cache = Cache()

  def interpolate(self, expr):
    return interpolate(expr, self.VV)

  def calculate_v(self, state, dt):
    """
    Calculate :math:`\\vec{v}` according to the algorithm introduced above.

    *Arguments*
        state (:class:`State`)
            The simulation state containing the magnetization configuration.
        dt (:class:`float`)
            The time-step size.
    """


    with Timer("Calculate v"):
      cache = self._assemble_cache
      if cache.requires_update(state):

        if isinstance(state.mesh, WrappedMesh):
          raise Exception("Use simple mesh with shell instead of WrappedMesh.")

        # setup function spaces
        cache.VV = VectorFunctionSpace(state.mesh, "CG", 1)
        cache.VD = FunctionSpace(state.mesh, "CG", self.demag_order)
        cache.VL = FunctionSpace(state.mesh, "CG", 1)

        # setup some stuff for the demag field
        transformation_order = 2 if (self.demag_order == 1) else 2
        shell_width = state.mesh.coordinates().max(axis=0).min() / 2.0
        sample_size = state.mesh.coordinates().max(axis=0) - shell_width
        cache.gx = MetricMatrix.create_for_cube(sample_size, 0, transformation_order)
        cache.gy = MetricMatrix.create_for_cube(sample_size, 1, transformation_order)
        cache.gz = MetricMatrix.create_for_cube(sample_size, 2, transformation_order)

      # Test and Trial Functions
      u     = TrialFunction(cache.VD)
      v     = TrialFunction(cache.VV)
      sigma = TrialFunction(cache.VL)

      w1    = TestFunction(cache.VD)
      w2    = TestFunction(cache.VV)
      w3    = TestFunction(cache.VL)

      #######################################################
      # Define weak forms
      #######################################################
      f_ex = (- 2.0 * state.material.Aex * Constants.gamma) / \
             (Constants.mu0 * state.material.ms * state.scale**2)

      # Bilinear form
      a12  = - 0.5 * Constant(dt) * inner(v, grad(w1)) * state.dx('magnetic')                            # Demag Field, Implicit RHS
      a11  = inner(grad(w1), grad(u))            * state.dx('all') \
           + inner(grad(w1), grad(u))            * state.dx(1000)  \
           + inner(grad(w1), cache.gx * grad(u)) * state.dx(1001)  \
           + inner(grad(w1), cache.gy * grad(u)) * state.dx(1002)  \
           + inner(grad(w1), cache.gz * grad(u)) * state.dx(1003)
      a21  = - Constant(state.material.ms * Constants.gamma) * inner(grad(u), w2) * state.dx('magnetic') # Demag
      a22  = Constant(state.material.alpha) * dot(v, w2) * state.dx('magnetic')                          # LLG
      a22 += dot(cross(state.m, v), w2) * state.dx('magnetic')
      a22 += - 0.5 * Constant(dt * f_ex) * Dx(v[i],j) * Dx(w2[i],j) * state.dx('magnetic')               # Exchange

      # Linear form
      L1 = inner(state.m, grad(w1)) * state.dx('magnetic')                                               # Demag Field
      L2 = Constant(f_ex) * Dx(state.m[i],j) * Dx(w2[i],j) * state.dx('magnetic')                        # Exchange

      for term in self.terms:                                                                            # Additional Terms
        L2  += term.form_rhs(state, w2) * state.dx('magnetic')
        #a22 += term.form_lhs(state, w2, Constant(0.5 * dt) * v) * state.dx('magnetic')

      #######################################################
      # Define boundary conditions
      #######################################################
      bc1 = DirichletBC(cache.VD, Constant(0.0), DomainBoundary())

      #######################################################
      # Assemble the system
      #######################################################
      A11, b1 = assemble_system(a11, L1, bc1)
      A12 = assemble(a12)
      A21 = assemble(a21)
      A22 = assemble(a22, keep_diagonal=True); A22.ident_zeros()

      v23 = TestFunction(state.VectorFunctionSpace())
      u23 = TrialFunction(state.FunctionSpace())
      A23 = assemble(u23 * dot(state.m, v23) * dP)

      v32 = TestFunction(state.FunctionSpace())
      u32 = TrialFunction(state.VectorFunctionSpace())
      A32 = assemble(v32 * dot(state.m, u32) * dP)

      #A23 = DofAssembler.assemble(TransScalarProductMatrix(cache.VL, cache.VV, state.m))
      #A32 = DofAssembler.assemble(ScalarProductMatrix(cache.VL, cache.VV, state.m))

      b2  = assemble(L2)

      #######################################################
      # Schur Ansatz
      #######################################################
      A11p   = ILU(A11)
      A11inv = ConjGrad(A11, precond=A11p)
      z1     = A11inv * b1

      S11    = A22 - A21 * A11inv * A12
      S      = block_mat([[S11, A23],
                          [A32,   0]])

      Sp11   = ILU(A22)
      Sp22   = InvDiag(collapse(A32 * LumpedInvDiag(A22) * A23))
      Sp     = block_mat([[Sp11, A23],
                          [0, -Sp22]]).scheme('sgs')

      Sinv   = BiCGStab(S, precond=Sp, tolerance=1e-8/dt)

      b      = block_vec([b2 - A21*z1, 0])
      v, _   = Sinv * b

      return Function(cache.VV, v)

  def step(self, state, dt):
    """
    Calculate :math:`\\vec{m}(t+\Delta t)` for a given timestep.

    *Arguments*
        state (:class:`State`)
            The magnetization configuration.
        dt (:class:`float`)
            The time-step size.
    """

    with Timer("LLG Step"):
      v = self.calculate_v(state, dt)
      state.m.vector().axpy(dt, v.vector())
      # NOTE state.update_uuid() is not called, because normlize does the job
      state.m.normalize()
