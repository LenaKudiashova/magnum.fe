# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-02-17

from __future__ import absolute_import 

from dolfin import *
from . import Integrator
from magnumfe import Constants, Timer

__all__ = ["LLGAlougesProject"]

class LLGAlougesProject(Integrator):
  def __init__(self, terms = []):
    r"""
    Solver for the Landau-Lifshitz-Gilbert equation according to Alouges [Alouges2008]_. In this two-step algorithm :math:`\partial_t \vec{m} = \vec{v}` is computed as

    .. math::
        \int_\Omega ( \alpha \vec{v} + \vec{m} \times \vec{v}) \cdot \vec{w} \dx
        + \frac{2 A_\text{ex} \gamma}{\mu_0 M_\text{s}} \int_\Omega \nabla (\vec{m} + \frac{1}{2} k \vec{v}) \cdot \nabla \vec{w} \dx
        + \gamma \int_\Omega \vec{H}_\text{eff} \cdot \vec{w} \dx
        = 0 \quad \forall \quad \vec{w} \in T_{\vec{m}}

    where both the trial and test functions are restricted to :math:`T_{\vec{m}}` which is the tangent space of :math:`\vec{m}` [Abert2013b]_. As suggested in [Goldenits2012]_ the exchange field is integrated implicitly whereas all other contributions to the effective field :math:`\vec{H}_\text{eff}` are integrated explicitly. This class implements the tangent-space restriction through a projection method

    .. math::
      (\mat{I} - \mat{B}^T \mat{B}) \mat{A} \vec{v} = 
      (\mat{I} - \mat{B}^T \mat{B}) \vec{b}

    where :math:`\mat{A}` and :math:`\vec{b}` are the discretized bilinear and linear part of the weak formulation above and :math:`\mat{B}` is a matrix that delivers the node-wise scalar product with :math:`\vec{m}` if applied to a vector field (e.g. :math:`\vec{v}`).

    The integration step itself is performed by application of a node-wise renormalization as proposed by Alouges in [Alouges2008]_:

    .. math::
      \vec{m}_i(t+k) = \frac{\vec{m}_i(t) + k \vec{v}_i}{|\vec{m}_i(t) + k \vec{v}_i|}

    .. note:: This class requires the PETSc Backend to be enabled.

    *Arguments*
      terms (:class:`LLGTerm`)
        Effective Field terms to be considered.
    """

    if not has_linear_algebra_backend("PETSc"):
      raise Exception("LLGAlougesProject requires the PETSc backend to be active.")

    self.terms = terms

  def calculate_v(self, state, dt):
    """
    Calculate :math:`\\vec{v}` according to the algorithm introduced above.

    *Arguments*
        state (:class:`State`)
            The simulation state containing the magnetization configuration.
        dt (:class:`float`)
            The time-step size.
    """

    with Timer("Calculate v"):
      # Initialize mesh and function spaces
      VV = state.VectorFunctionSpace()
      VS = state.FunctionSpace()

      v  = TrialFunction(VV)
      w  = TestFunction(VV)

      #######################################################
      # Forms
      #######################################################
      f_ex  =  Constant(-2.0 / state.scale**2 * Constants.gamma / Constants.mu0) \
               * state.material.Aex / state.material.ms

      # Bilinear form for LLG
      a  = state.material.alpha * dot(v, w) * state.dx('magnetic')
      a += dot(cross(state.m, v), w) * state.dx('magnetic')
      L  = zero()

      # Effective field contributions
      for term in self.terms:
        L += term.form_rhs(state, w) * state.dx('magnetic')
        a += term.form_lhs(state, w, Constant(0.5 * dt) * v) * state.dx('magnetic')

      #######################################################
      # Assembly
      #######################################################

      # System to solve:
      # (1 - B^t B) A x = (1 - B^t B) b

      class ProjectionOperator(LinearOperator):
        def __init__(self, A, BTB, u):
          LinearOperator.__init__(self, u.vector(), u.vector())
          self._A   = A
          self._BTB = BTB

        def size(self):
          return self._A.size(0)

        def mult(self, x, y):
          self._BTB.transpmult(- self._A * x, y)
          y.axpy(1.0, self._A * x)

      A = assemble(a, keep_diagonal = True)
      A.ident_zeros()

      v = TestFunction(state.VectorFunctionSpace())
      u = TrialFunction(state.VectorFunctionSpace())
      BTB = assemble(inner(state.m, v) * inner(state.m, u) * dP)

      b = assemble(L)
      b.axpy(-1.0, BTB*b)

      v = Function(VV)
      Op = ProjectionOperator(A, BTB, v)

      with Timer("Solve"): solve(Op, v.vector(), b, "gmres")

      return v

  def step(self, state, dt):
    """
    Calculate :math:`\\vec{m}(t+\Delta t)` for a given timestep.

    *Arguments*
      state (:class:`State`)
        The magnetization configuration.
      dt (:class:`float`)
        The time-step size.
    """

    with Timer("LLG Step"):
      v = self.calculate_v(state, dt)
      state.m.vector().axpy(dt, v.vector())
      # NOTE state.update_uuid() is not called, because normlize does the job
      state.m.normalize()
