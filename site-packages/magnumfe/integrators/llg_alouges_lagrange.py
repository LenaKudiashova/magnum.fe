# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-02-17

from __future__ import absolute_import 

try:
  import scipy
  from block import *
  from block.iterative import BiCGStab
  from block.dolfin_util import *
  from block.algebraic.petsc import ILU, InvDiag, collapse, LumpedInvDiag
  _found_cbcblock = True
except:
  # TODO log warning (also distinguish scipy and cbc.block)
  _found_cbcblock = False

from dolfin import *
from . import Integrator
from magnumfe import Constants, Timer

__all__ = ["LLGAlougesLagrange"]

class LLGAlougesLagrange(Integrator):

  def __init__(self, terms = []):
    r"""
    Solver for the Landau-Lifshitz-Gilbert equation according to Alouges [Alouges2008]_. In this two-step algorithm :math:`\partial_t \vec{m} = \vec{v}` is computed as

    .. math::
        \int_\Omega ( \alpha \vec{v} + \vec{m} \times \vec{v}) \cdot \vec{w} \dx
        + \frac{2 A_\text{ex} \gamma}{\mu_0 M_\text{s}} \int_\Omega \nabla (\vec{m} + \frac{1}{2} k \vec{v}) \cdot \nabla \vec{w} \dx
        + \gamma \int_\Omega \vec{H}_\text{eff} \cdot \vec{w} \dx
        = 0 \quad \forall \quad \vec{w} \in T_{\vec{m}}

    where both the trial and test functions are restricted to :math:`T_{\vec{m}}` which is the tangent space of :math:`\vec{m}` [Abert2013b]_. As suggested in [Goldenits2012]_ the exchange field is integrated implicitly whereas all other contributions to the effective field :math:`\vec{H}_\text{eff}` are integrated explicitly. This class implements the tangent-space restriction through a Lagrange multiplier ansatz as proposed in [Goldenits2012]_.

    .. math::
      \begin{pmatrix}
          \mat{A} & \mat{B} \\ \mat{B}^T & 0
      \end{pmatrix}
      \begin{pmatrix}
        \vec{v} \\ \lambda
      \end{pmatrix}
      =
      \begin{pmatrix}
        \vec{b} \\ 0
      \end{pmatrix}

    where :math:`\mat{A}` and :math:`\vec{b}` are the discretized bilinear and linear part of the weak formulation above and :math:`\mat{B}` is a matrix that delivers the node-wise scalar product with :math:`\vec{m}` if applied to a vector field (e.g. :math:`\vec{v}`).

    The integration step itself is performed by application of a node-wise renormalization as proposed by Alouges in [1]:

    .. math::
      \vec{m}_i(t+k) = \frac{\vec{m}_i(t) + k \vec{v}_i}{|\vec{m}_i(t) + k \vec{v}_i|}

    .. note:: This class requires CBC.Block and the PETSc linear-algebra backend.

    *Arguments*
      terms (:class:`LLGTerm`)
        Effective Field terms to be considered.
    """

    if not has_linear_algebra_backend("PETSc"):
      raise Exception("LLGAlougesFullImplicit requires the PETSc backend to be active.")

    if not _found_cbcblock:
      raise Exception("LLGAlougesFullImplicit requires the CBC.Block library.")

    self.terms = terms

  def calculate_v(self, state, dt):
    """
    Calculate :math:`\\vec{v}` according to the algorithm introduced above.

    *Arguments*
      state (:class:`State`)
        The simulation state containing the magnetization configuration.
      dt (:class:`float`)
        The time-step size.
    """

    with Timer("Calculate v"):
      # Initialize mesh and function spaces
      VV = state.VectorFunctionSpace()
      VS = state.FunctionSpace()

      v  = TrialFunction(VV)
      w  = TestFunction(VV)

      #######################################################
      # Forms
      #######################################################
      f_ex  =  Constant(-2.0 / state.scale**2 * Constants.gamma / Constants.mu0) \
               * state.material.Aex / state.material.ms

      # Bilinear form for LLG
      a  = state.material.alpha * dot(v, w) * state.dx('magnetic')
      a += dot(cross(state.m, v), w) * state.dx('magnetic')
      L  = zero()

      # Effective field contributions
      for term in self.terms: 
        L += term.form_rhs(state, w) * state.dx('magnetic')
        a += term.form_lhs(state, w, Constant(0.5 * dt) * v) * state.dx('magnetic')

      #######################################################
      # Assembly
      #######################################################

      # assemble llg
      A = assemble(a, keep_diagonal = True)
      A.ident_zeros()
      b = assemble(L)

      # assemble constraint
      #B  = DofAssembler.assemble(ScalarProductMatrix(VS, VV, state.m))
      #BT = DofAssembler.assemble(TransScalarProductMatrix(VS, VV, state.m))

      v  = TestFunction(state.FunctionSpace())
      u  = TrialFunction(state.VectorFunctionSpace())
      B  = assemble(v * dot(state.m, u) * dP)

      v  = TestFunction(state.VectorFunctionSpace())
      u  = TrialFunction(state.FunctionSpace())
      BT = assemble(u * dot(state.m, v) * dP)

      # assemble block matrix
      AA = block_mat([[A, BT],
                      [B, 0]])
      bb = block_vec([b, BT.create_vec()])

      Ap = ILU(A)
      Bp = InvDiag(collapse(B*LumpedInvDiag(A)*BT))
      AAp = block_mat([[Ap, BT],
                       [0, -Bp]]).scheme('sgs')

      #######################################################
      # Solve the system
      #######################################################
      AAinv = BiCGStab(AA, precond=AAp, tolerance=1e-8/dt)
      u, foo = AAinv*bb

      v = Function(VV)
      v.vector()[:] = u

      return v

  def step(self, state, dt):
    """
    Calculate :math:`\\vec{m}(t+\Delta t)` for a given timestep.

    *Arguments*
      state (:class:`State`)
        The simulation state.
      dt (:class:`float`)
        The time-step size.
    """

    with Timer("LLG Step"):
      v = self.calculate_v(state, dt)
      state.m.vector().axpy(dt, v.vector())
      # NOTE state.update_uuid() is not called, because normlize does the job
      state.m.normalize()
