# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-02-16

from __future__ import absolute_import 

from dolfin import *
from . import Integrator
from magnumfe import Constants, Timer

__all__ = ["SpinDiffusion"]

class SpinDiffusion(Integrator):

  def __init__(self):
    r"""
    Solver for the spin-diffusion equation according to [Abert2014a]_. The spin diffusion :math:`\vec{s}` is computed from the current magnetization :math:`\vec{m}` by

    .. math::
        \int_{\Omega} \;\text{d}_{t} \boldsymbol{s}^{k+1} \cdot \boldsymbol{\zeta} \;\text{d}\boldsymbol{x}
        \;+\; 2 D_0 \, a(\boldsymbol{s}^{k+1}, \boldsymbol{\zeta})
        =\\
        \frac{\beta \mu_\text{B}}{e} \int_{\omega} \left[ \boldsymbol{m}^{k+1} \otimes \boldsymbol{j}^{k+1} \right] : \boldsymbol{\nabla} \boldsymbol{\zeta} \;\text{d}\boldsymbol{x}
        - \frac{\beta \mu_\text{B}}{e} \int_{\partial \Omega \cap \partial \omega} (\boldsymbol{j}^{k+1} \cdot \boldsymbol{n}) (\boldsymbol{m}^{k+1} \cdot \boldsymbol{\zeta}) \;\text{d}\boldsymbol{x}

    where :math:`\text{d}_t \vec{s}^{k+1} = (\vec{s}^{k+1} - \vec{s}^k)` and the bilinear form :math:`a(\zeta_1, \zeta_2)` is defined as

    .. math::
      a(\boldsymbol{\zeta_1}, \boldsymbol{\zeta_2}) =
      \frac{1}{\lambda_\text{sf}^2} \int_{\Omega} \boldsymbol{\zeta}_1 \cdot \boldsymbol{\zeta}_2 \;\text{d}\boldsymbol{x}
      + \int_{\Omega} \boldsymbol{\nabla} \boldsymbol{\zeta}_1 : \boldsymbol{\nabla} \boldsymbol{\zeta}_2 \;\text{d}\boldsymbol{x}
      \\
      - \beta \beta' \int_{\omega} \left[ \boldsymbol{m}^{k+1} \otimes \left((\boldsymbol{\nabla} \boldsymbol{\zeta}_1)^T \boldsymbol{m}^{k+1} \right) \right] : \boldsymbol{\nabla} \boldsymbol{\zeta}_2 \;\text{d}\boldsymbol{x}
      + \frac{1}{\lambda_\text{J}^2} \int_{\omega} \left( \boldsymbol{\zeta}_1 \times \boldsymbol{m}^{k+1} \right) \cdot \boldsymbol{\zeta}_2 \;\text{d}\boldsymbol{x}.

    The region :math:`\Omega` corresponds to the "conducting" cell domain and the region :math:`\omega` corresponds to the "magnetic" cell domain. The boundary :math:`\partial \Omega \cap \partial \omega` has to be defined explicitly as facet domain named "outermagnet".

    The characteric time scale of the spin-diffusion dynamics is orders of magnitude smaller than that of the magnetization dynamics. However, the integration scheme is able to handle very large time steps. Hence the time step can be taken from the integration of the LLG if only the magnetization dynamics are of interest, see [Abert2014b]_.

    Add the :class:`SpinCurrent` to the LLG terms in order to get a bidirectional coupling of spin diffusion and magnetization.
    """
    pass
  
  def step(self, state, dt):
    """
    Calculate :math:`\\vec{s}(t+\Delta t)` for a given timestep.

    *Arguments*
      state (:class:`State`)
        The simulation state.
      dt (:class:`float`)
        The time-step size.
    """

    with Timer("Spin-Diffusion Step"):
      # regions
      Omega = 'conducting'
      omega = 'magnetic'

      # Functions Spaces ...
      VV   = state.VectorFunctionSpace()
      s    = TrialFunction(VV)   # s_i+1
      zeta = TestFunction(VV)    # zeta

      D0x2       = state.material.D0 * Constant(2.0)
      beta       = state.material.beta
      beta_prime = state.material.beta_prime
      lambda_sf  = state.material.lambda_sf
      lambda_j   = state.material.lambda_j

      grad = lambda x: transpose(nabla_grad(x))
      n    = FacetNormal(state.mesh)

      # Forms
      a = inner(s, zeta) / Constant(dt) * state.dx(Omega)                                                                                         \
        + D0x2 / Constant(state.scale**2) * inner(grad(s), grad(zeta)) * state.dx(Omega)                                                          \
        - D0x2 / Constant(state.scale**2) * beta * beta_prime * inner(outer(state.m, transpose(grad(s)) * state.m), grad(zeta)) * state.dx(omega) \
        + D0x2 / lambda_sf**2 * inner(s, zeta) * state.dx(Omega)                                                                                  \
        + D0x2 / lambda_j**2 * inner(cross(s, state.m), zeta) * state.dx(omega)

      L = inner(state.s, zeta) / Constant(dt) * state.dx(Omega)                                                                                   \
        + beta * Constant(Constants.mu_b / Constants.e / state.scale) * inner(outer(state.m, state.j), grad(zeta)) * state.dx(omega)              \
        - beta * Constant(Constants.mu_b / Constants.e / state.scale) * inner(state.m, zeta) * inner(state.j, n) * state.ds('outermagnet')

      # Solve system
      A, b = assemble_system(a, L)

      s = Function(state.VectorFunctionSpace())
      solver = KrylovSolver(A, "gmres", "ilu")
      solver.solve(s.vector(), b)

      state.s = s
