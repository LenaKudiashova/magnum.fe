"""This module defines a class for the coupling of the spin diffusion
to the magnetization."""

# Copyright (C) 2011-2012 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# First added:  2012-11-30
# Last changed: 2012-11-30
from __future__ import absolute_import 
from dolfin import *

__all__ = ["SpinDiffusion"]

class SpinDiffusion(object):
  def __init__(self):
    pass
  
  def step(self, state, dt):
    # regions
    Omega = 'conducting'
    omega = 'magnetic'

    # Functions Spaces ...
    VV   = state.VectorFunctionSpace()
    s    = TrialFunction(VV)   # s_i+1
    zeta = TestFunction(VV)    # zeta

    D0         = state.material.D0
    beta       = state.material.beta
    beta_prime = state.material.beta_prime
    j          = state.j

    s_prev = state.s                 # s_i

    # zeta1 = s ; zeta2 = zeta

    s_diff = (s - s_prev) / dt # dt s_i+1

    pde = inner(s_diff, zeta) * state.dx(Omega) +                                                                     \
        + D0 * inner(grad(s), grad(zeta)) * state.dx(Omega)                                                           \ 
        - D0 * beta * beta_prime * inner(outer(state.m, nabla_grad(s) * state.m), nabla_grad(zeta)) * state.dx(omega) \
        + D0 * inner(s , zeta) * state.dx(Omega)                                                                      \
        + D0 * inner(cross(s, state.m), zeta) * state.dx(omega)                                                       \
        - beta * inner(outer(state.m, j), nabla_grad(zeta)) * state.dx(omega)

    # Solve system
    s = Function(state.VectorFunctionSpace())

    A, b = assemble_system(system(pde))

    solver = KrylovSolver(A, "gmres")
    solver.solve(s.vector(), b)

    state.s.assign(s)
