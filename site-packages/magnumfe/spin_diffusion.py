# Copyright (C) 2011-2014 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2014-07-11
from __future__ import absolute_import 
from dolfin import *

from magnumfe.constants import Constants

__all__ = ["SpinDiffusion"]

class SpinDiffusion(object):
  def __init__(self, scale = 1.0):
    self.scale = scale
  
  def step(self, state, dt):
    # regions
    Omega = 'conducting'
    omega = 'magnetic'

    # Functions Spaces ...
    VV   = state.VectorFunctionSpace()
    s    = TrialFunction(VV)   # s_i+1
    zeta = TestFunction(VV)    # zeta

    D0x2       = state.material.D0 * Constant(2.0)
    beta       = state.material.beta
    beta_prime = state.material.beta_prime
    lambda_sf  = state.material.lambda_sf
    lambda_j   = state.material.lambda_j

    grad = lambda x: transpose(nabla_grad(x))
    n    = FacetNormal(state.mesh)

    # Forms
    a = inner(s, zeta) / Constant(dt) * state.dx(Omega)                                                                             \
      + D0x2 / Constant(self.scale**2) * inner(grad(s), grad(zeta)) * state.dx(Omega)                                               \
      - D0x2 / Constant(self.scale**2) * beta * beta_prime * inner(outer(state.m, transpose(grad(s)) * state.m), grad(zeta)) * state.dx(omega) \
      + D0x2 / lambda_sf**2 * inner(s, zeta) * state.dx(Omega)                                                                      \
      + D0x2 / lambda_j**2 * inner(cross(s, state.m), zeta) * state.dx(omega)

    L = inner(state.s, zeta) / Constant(dt) * state.dx(Omega)                                                                       \
      + beta * Constant(Constants.mu_b / Constants.e / self.scale) * inner(outer(state.m, state.j), grad(zeta)) * state.dx(omega)   \
      - beta * Constant(Constants.mu_b / Constants.e / self.scale) * inner(state.m, zeta) * inner(state.j, n) * state.ds('outermagnet')

    # Solve system
    A, b = assemble_system(a, L)

    s = Function(state.VectorFunctionSpace())
    solver = KrylovSolver(A, "gmres")
    solver.solve(s.vector(), b)

    state.s.assign(s)
