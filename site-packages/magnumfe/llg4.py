"""This module defines an alternative class for the numerical integration of the LLG."""

# Copyright (C) 2011-2012 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# First added:  2012-11-30
# Last changed: 2012-11-30

from __future__ import absolute_import 

import scipy
from dolfin import *
from block  import *
from block.algebraic import *
from block.iterative import *
from block.algebraic.trilinos import *
from block.dolfin_util import *
from magnumfe import *

__all__ = ["LLG4"]

class LLG4:
  """
  This class defines methods for the numerical integration of the LLG. The
  effective field includes exchange, demagnetization and external field terms.

  As opposed to the LLG class here CBC.Block is used and the micromagnetic
  constraint is imposed only on the nodes.
  """

  def __init__(self, mesh, material, **kwargs):
    """
    Create a _LLG2_ object for a given mesh and material.

    *Arguments*
        mesh
            The mesh.
        material
            The material of the sample.
        scale
            The scaling of the model. Use 1e-9 if you use nanometers as length measure.
    """

    # parameters
    self.mesh         = mesh.with_shell
    self.wrapped_mesh = mesh
    self.material     = material
    self.scale        = kwargs.pop('scale', 1.0)
    self.demag_order  = kwargs.pop('demag_order', 2)

    # setup function spaces
    self.VV = VectorFunctionSpace(self.mesh, "CG", 1)
    self.VD = FunctionSpace(self.mesh, "CG", self.demag_order)
    self.VL = FunctionSpace(self.mesh, "CG", 1)
    #self.V  = MixedFunctionSpace([self.VV, self.VD, self.VL])

    # setup some stuff for the demag field
    sample_size = mesh.data['sample_size']
    transformation_order = 2 if (self.demag_order == 1) else 2
    self.gx = MetricMatrix.create_for_cube(sample_size, 0, transformation_order)
    self.gy = MetricMatrix.create_for_cube(sample_size, 1, transformation_order)
    self.gz = MetricMatrix.create_for_cube(sample_size, 2, transformation_order)
    
  def interpolate(self, expr):
    return interpolate(expr, self.VV)

  def calculate_dm(self, m, dt, **kwargs):
    """
    Calculate the dm for a given magnetization configuration and timestep
    by the semiimplicit method proposed by Alouge.

    *Arguments*
        m
            The magnetization configuration.
        dt
            The timestep.
        u_ext
            The external field.
    """

    # get optional parameters
    h_ext   = kwargs.pop('h_ext', None)

    # Test and Trial Functions
    u     = TrialFunction(self.VD)
    v     = TrialFunction(self.VV)
    sigma = TrialFunction(self.VL)

    w1    = TestFunction(self.VD)
    w2    = TestFunction(self.VV)
    w3    = TestFunction(self.VL)

    #######################################################
    # Define weak forms
    #######################################################
    f_ex = (- 2.0 * self.material.Aex * self.material.gamma) / \
           (Constants.mu0 * self.material.ms * self.scale**2)

    # Bilinear form
    a12  = - 0.5 * dt * inner(v, grad(w1)) * dx(0)                              # Demag Field, Implicit RHS
    a11  = Dx(w1, i) * Dx(u, i)                * dx(0) + \
           Dx(w1, i) * Dx(u, i)                * dx(1) + \
           Dx(w1, i) * self.gx[i,j] * Dx(u, j) * dx(2) + \
           Dx(w1, i) * self.gy[i,j] * Dx(u, j) * dx(3) + \
           Dx(w1, i) * self.gz[i,j] * Dx(u, j) * dx(4)                          # Demag Field, Stiffness
    a21  = - self.material.ms * self.material.gamma * inner(grad(u), w2) * dx   # Demag
    a22  = self.material.alpha * dot(v, w2) * dx + dot(cross(m, v), w2) * dx    # LLG
    a22 += - 0.5 * dt * f_ex * Dx(v[i],j) * Dx(w2[i],j) * dx                    # Exchange

    #a23  = sigma * inner(m, w2) * dx                                            # Lagrange Multipliers
    #a32  = inner(m, v) * w3 * dx                                                # Constraint

    # Linear form
    L1 = inner(m, grad(w1)) * dx(0)                                             # Demag Field
    L2 = f_ex * Dx(m[i],j) * Dx(w2[i],j) * dx                                   # Exchange

    #if (h_ext is not None):                                              # External
    #  L += self.material.gamma * inner(h_ext, w2) * dx

    #######################################################
    # Define boundary conditions
    #######################################################
    bc1 = DirichletBC(self.VD, Constant(0.0), DomainBoundary())
    #bcs  = [None, bc22, None]

    #######################################################
    # Assemble the system
    #######################################################
    A11, A11n = symmetric_assemble(a11, bc1)
    A12 = assemble(a12)
    A21 = assemble(a21)
    A22 = assemble(a22); A22.ident_zeros()
    #A23 = assemble(a23)
    #A32 = assemble(a32)
    A23 = DofAssembler.assemble(TransScalarProductMatrix(self.VL, self.VV, m))
    A32 = DofAssembler.assemble(ScalarProductMatrix(self.VL, self.VV, m))

    b1  = assemble(L1)
    b2  = assemble(L2)

    # Apply BCs
    bc1.apply(b1)
    b1 = b1 - A11n * b1
    #b = block_vec([b1, b2])

    #######################################################
    # Schur Ansatz
    #######################################################

    A11p   = ML(A11)
    A11inv = ConjGrad(A11, precond=A11p)
    z1     = A11inv * b1

    S11    = A22 - A21 * A11inv * A12
    S      = block_mat([[S11, A23],
                        [A32,   0]])
    Sp11   = ILU(A22)
    Sp22   = ML(collapse(A32 * InvDiag(A22) * A23))
    Sp     = block_mat([[Sp11, A23],
                        [A32, -Sp22]]).scheme('sgs')

    Sinv   = BiCGStab(S, precond=Sp)

    b      = block_vec([b2, 0])
    x      = Sinv * b

    return
    S      = block_mat([[A22 - A21 * A11inv * A12, A23], [A32, 0]])
    Sp     = block_mat([[ILU(A22), 0], [0, InvDiag(collapse(A32 * A23))]])
    Sinv   = LGMRES(S, precond=Sp)

    x      = Sinv * (block_vec([b2 - A21*z1, 0]))
    return
             
    # v, u, sigma
    x1, x2, x3 = Ainv * b

    #dm = interpolate(x1, self.VV)
    dm = Function(self.VV)
    dm.vector()[:] = x1[:]
    return dm

  def step(self, m, dt, **kwargs):
    """
    Calculate m(t+dt) for a given m(t) and dt following the semiimplicit
    method proposed by Alouge.
    The effective field consists of the stray field and the exchange field.
    An optional external field can be passed as argument.

    *Arguments*
        m
            The magnetization configuration.
        dt
            The timestep.
        h_ext
            The external field.
    """

    h_ext = kwargs.pop('h_ext', None)

    dm      = self.calculate_dm(m, dt, h_ext=h_ext)
    m.vector().axpy(dt, dm.vector())

    return Function(self.VV, DofAssembler.assemble(NormalizedVector(self.VV, m)))
