from __future__ import absolute_import 
from dolfin import *
from magnumfe import Mesher
from magnumfe.cpp import SubMeshInterpolator

__all__ = ["WrappedMesh"]

class WrappedMesh(Mesh):
  def init(self, mesh_with_shell, data={}):
    self.data       = data
    self.with_shell = mesh_with_shell

    # Cache for interpolators
    # The signature of the element is used as key
    self._interpolators = {}

  def cut(self, f, **kwargs):
    # create target function space
    element = f.function_space().ufl_element()
    V       = FunctionSpaceBase(self, element)

    # Cut and return
    result = Function(V)
    interpolator = self._get_interpolator(f.function_space())
    interpolator.cut(f.vector(), result.vector())

    return result

  def expand(self, f, **kwargs):
    # create target function space
    element = f.function_space().ufl_element()
    V       = FunctionSpaceBase(self.with_shell, element)

    # Cut and return
    result = Function(V)
    interpolator = self._get_interpolator(f.function_space())
    interpolator.expand(f.vector(), result.vector())

    return result

  def _get_interpolator(self, V):
    # Get or create interpolator
    element = V.ufl_element()
    key = V.element().signature()

    if not self._interpolators.has_key(key):
      Vsub   = FunctionSpaceBase(self, element)
      Vsuper = FunctionSpaceBase(self.with_shell, element)
      self._interpolators[key] = SubMeshInterpolator(Vsuper, Vsub)

    return self._interpolators[key]

  @staticmethod
  def create(mesh, subdomain, data = {}):
    submesh = SubMesh(mesh, mesh.domains().cell_domains(mesh), subdomain)

    submesh.__class__  = WrappedMesh
    submesh.init(mesh, data)

    return submesh
