# Copyright (C) 2011-2014 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2014-09-30

from __future__ import absolute_import 

from dolfin import Function, MeshFunction, Mesh, SubMesh, CellFunction, FunctionSpaceBase
from magnumfe import Mesher
from magnumfe.cpp import SubMeshInterpolator

__all__ = ["WrappedMesh"]

class WrappedMesh(Mesh):

  def __init__(self, *args, **kwargs):
    """
    This class represents a mesh with a certain submesh and defines
    methods for the fast interpolation between the two meshes.
    """
    super(WrappedMesh, self).__init__(*args, **kwargs)

  def _init(self, mesh_with_shell):
    """
    Initialize the mesh instance.

    *Arguments*
      mesh_with_shell (:class:`dolfin.Mesh`)
        The super mesh
    """
    self.with_shell = mesh_with_shell

    # Cache for interpolators
    # The signature of the element is used as key
    self._interpolators = {}

  def cut(self, f, **kwargs):
    """
    Takes a function defined on the super mesh and returns a truncated
    function defined on the sub mesh.

    *Arguments*
      f (:class:`dolfin.Function`)
        The function on the super mesh.

    *Returns*
      :class:`dolfin.Function`
        The function on the sub mesh.
    """

    # create target function space
    element = f.function_space().ufl_element()
    V       = FunctionSpaceBase(self, element)

    # Cut and return
    result = Function(V)
    interpolator = self._get_interpolator(f.function_space())
    interpolator.cut(f.vector(), result.vector())

    result.rename(f.name(), f.label())
    return result

  def expand(self, f, **kwargs):
    """
    Takes a function defined on the sub mesh and returns a function
    defined on the super mesh with unknown values set to zero.

    *Arguments*
      f (:class:`dolfin.Function`)
        The function on the sub mesh.

    *Returns*
      The function on the super mesh.
    """

    # create target function space
    element = f.function_space().ufl_element()
    V       = FunctionSpaceBase(self.with_shell, element)

    # Cut and return
    result = Function(V)
    interpolator = self._get_interpolator(f.function_space())
    interpolator.expand(f.vector(), result.vector())

    result.rename(f.name(), f.label())
    return result

  def _get_interpolator(self, V):
    """
    Create and cache instances of SubMeshInterpolator.
    """
    # Get or create interpolator
    element = V.ufl_element()
    key = V.element().signature()

    if not self._interpolators.has_key(key):
      Vsub   = FunctionSpaceBase(self, element)
      Vsuper = FunctionSpaceBase(self.with_shell, element)
      self._interpolators[key] = SubMeshInterpolator(Vsuper, Vsub)

    return self._interpolators[key]

  @staticmethod
  def create(mesh, domain_ids, invert=False):
    """
    Creates a wrapped mesh from a super mesh for a given collection
    of domain IDs.

    *Arguments*
      mesh (:class:`dolfin.Mesh`)
        The mesh.
      domain_ids (:class:`[int]`)
        List of domain IDs
      invert (:class:`bool`)
        Invert list of domain IDs

    *Returns*
      :class:`WrappedMesh`
        The wrapped mesh
    """
    if invert or isinstance(domain_ids, list) or isinstance(domain_ids, tuple):
      if isinstance(domain_ids, int): domain_ids = (domain_ids,)

      subdomains = MeshFunction('size_t', mesh, 3, mesh.domains())
      combined_subdomains = CellFunction("size_t", mesh, 0)
      for domain_id in domain_ids:
        combined_subdomains.array()[subdomains.array() == domain_id] = 1

      submesh = SubMesh(mesh, combined_subdomains, 0 if invert else 1)
    else:
      submesh = SubMesh(mesh, domain_ids)

    submesh.__class__  = WrappedMesh
    submesh._init(mesh)

    return submesh
