"""This module defines a class for the handling of meshes with shells as used
for the stray-field transformation method."""

# Copyright (C) 2011-2012 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# First added:  2012-11-30
# Last changed: 2012-11-30

from __future__ import absolute_import 

from dolfin import *
from magnumfe import Mesher
from magnumfe.cpp import SubMeshInterpolator

__all__ = ["WrappedMesh"]

class WrappedMesh(Mesh):
  """
  This class represents a mesh with a certain submesh and defines
  methods for the fast interpolation between the two meshes.
  """

  def init(self, mesh_with_shell):
    """
    Creates a _WrappedMesh_. This method is not supposed to be called
    by the end user. Use the static create() method instead.
    """

    self.with_shell = mesh_with_shell

    # Cache for interpolators
    # The signature of the element is used as key
    self._interpolators = {}

  # TODO remove cell_domains completely from domainas container?
  def cell_domains(self):
    """
    Returns the domains attached to the mesh with shell
    """
    return MeshFunction('size_t', self.with_shell, 3, self.with_shell.domains())

  def cut(self, f, **kwargs):
    """
    Takes a function defined on the super mesh and returns a truncated
    function defined on the sub mesh.

    *Arguments*
        f
            The function on the super mesh.
    """

    # create target function space
    element = f.function_space().ufl_element()
    V       = FunctionSpaceBase(self, element)

    # Cut and return
    result = Function(V)
    interpolator = self._get_interpolator(f.function_space())
    interpolator.cut(f.vector(), result.vector())

    return result

  def expand(self, f, **kwargs):
    """
    Takes a function defined on the sub mesh and returns a function
    defined on the super mesh with unknown value set to zero.

    *Arguments*
        f
            The function on the sub mesh.
    """

    # create target function space
    element = f.function_space().ufl_element()
    V       = FunctionSpaceBase(self.with_shell, element)

    # Cut and return
    result = Function(V)
    interpolator = self._get_interpolator(f.function_space())
    interpolator.expand(f.vector(), result.vector())

    return result

  def _get_interpolator(self, V):
    """
    Create and cache instances of SubMeshInterpolator.
    """
    # Get or create interpolator
    element = V.ufl_element()
    key = V.element().signature()

    if not self._interpolators.has_key(key):
      Vsub   = FunctionSpaceBase(self, element)
      Vsuper = FunctionSpaceBase(self.with_shell, element)
      self._interpolators[key] = SubMeshInterpolator(Vsuper, Vsub)

    return self._interpolators[key]

  @staticmethod
  def create(mesh, domain_ids):
    """
    Creates a wrapped mesh from a super mesh with subdomains and a given
    subdomain number.

    *Arguments*
        mesh
            The mesh.
        domain_ids
            List of domain IDs
    """
    if isinstance(domain_ids, list) or isinstance(domain_ids, tuple):
      subdomains  = MeshFunction('size_t', mesh, 3, mesh.domains())
      combined_subdomains = CellFunction("size_t", mesh, 0)
      for domain_id in domain_ids:
        combined_subdomains.array()[subdomains.array() == domain_id] = 1
      submesh = SubMesh(mesh, combined_subdomains, 1)
    else:
      submesh = SubMesh(mesh, domain_ids)

    submesh.__class__  = WrappedMesh
    submesh.init(mesh)

    return submesh
