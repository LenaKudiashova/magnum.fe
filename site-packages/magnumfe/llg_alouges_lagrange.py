# Copyright (C) 2011-2014 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2014-10-01

from __future__ import absolute_import 

try:
  import scipy
  from block import *
  from block.iterative import BiCGStab
  from block.dolfin_util import *
  _found_cbcblock = True
except:
  # TODO log warning (also distinguish scipy and cbc.block)
  _found_cbcblock = False

from magnumfe import DofAssembler, ScalarProductMatrix, TransScalarProductMatrix, Constants, NormalizedVector

import time

__all__ = ["LLGAlougesLagrange"]

class LLGAlougesLagrange(object):

  def __init__(self, terms = [], scale = 1.0):
    r"""
    Solver for the Landau-Lifshitz-Gilbert equation according to Alouges [Alouges2008]_. In this two-step algorithm :math:`\partial_t \vec{m} = \vec{v}` is computed as

    .. math::
        \int_\Omega ( \alpha \vec{v} + \vec{m} \times \vec{v}) \cdot \vec{w} \dx
        + \frac{2 A_\text{ex} \gamma}{\mu_0 M_\text{s}} \int_\Omega \nabla (\vec{m} + \frac{1}{2} k \vec{v}) \cdot \nabla \vec{w} \dx
        + \gamma \int_\Omega \vec{H}_\text{eff} \cdot \vec{w} \dx
        = 0 \quad \forall \quad \vec{w} \in T_{\vec{m}}

    where both the trial and test functions are restricted to :math:`T_{\vec{m}}` which is the tangent space of :math:`\vec{m}` [Abert2013b]_. As suggested in [Goldenits2012]_ the exchange field is integrated implicitly whereas all other contributions to the effective field :math:`\vec{H}_\text{eff}` are integrated explicitly. This class implements the tangent-space restriction through a Lagrange multiplier ansatz as proposed in [Goldenits2012]_.

    .. math::
      \begin{pmatrix}
          \mat{A} & \mat{B} \\ \mat{B}^T & 0
      \end{pmatrix}
      \begin{pmatrix}
        \vec{v} \\ \lambda
      \end{pmatrix}
      =
      \begin{pmatrix}
        \vec{b} \\ 0
      \end{pmatrix}

    where :math:`\mat{A}` and :math:`\vec{b}` are the discretized bilinear and linear part of the weak formulation above and :math:`\mat{B}` is a matrix that delivers the node-wise scalar product with :math:`\vec{m}` if applied to a vector field (e.g. :math:`\vec{v}`).

    The integration step itself is performed by application of a node-wise renormalization as proposed by Alouges in [1]:

    .. math::
      \vec{m}_i(t+k) = \frac{\vec{m}_i(t) + k \vec{v}_i}{|\vec{m}_i(t) + k \vec{v}_i|}

    .. note:: This class requires CBC.Block.

    *Arguments*
      terms (:class:`LLGTerm`)
        Effective Field terms to be considered.
      scale (:class:`float`)
        The scaling of the model. Use 1e-9 if you use nanometers as length measure.
    """

    #if not _found_cbcblock: TODO log warning
    self.terms = terms
    self.scale = scale

  def calculate_v(self, state, dt):
    """
    Calculate :math:`\\vec{v}` according to the algorithm introduced above.

    *Arguments*
      state (:class:`State`)
        The simulation state containing the magnetization configuration.
      dt (:class:`float`)
        The time-step size.
    """

    if parameters["linear_algebra_backend"] == "Epetra":
      from block.algebraic.trilinos import DD_ILU, InvDiag, collapse, LumpedInvDiag
      ILU = DD_ILU
    elif parameters["linear_algebra_backend"] == "PETSc":
      from block.algebraic.petsc import ILU, InvDiag, collapse, LumpedInvDiag
    else:
      raise Exception("Backend not supported")

    # Initialize mesh and function spaces
    VV = state.VectorFunctionSpace()
    VS = state.FunctionSpace()

    v  = TrialFunction(VV)
    w  = TestFunction(VV)

    #######################################################
    # Forms
    #######################################################
    f_ex  =  Constant(-2.0 / self.scale**2 * Constants.gamma / Constants.mu0) \
             * state.material.Aex / state.material.ms

    # Bilinear form
    a  = state.material.alpha * dot(v, w) * state.dx('magnetic')
    a += dot(cross(state.m, v), w) * state.dx('magnetic')                            # LLG
    a += Constant(-0.5 * dt) * f_ex * Dx(v[i],j) * Dx(w[i],j) * state.dx('magnetic') # Exchange

    # Linear form
    L  = f_ex * Dx(state.m[i],j) * Dx(w[i],j) * state.dx('magnetic')                 # Exchange
    for term in self.terms:                                                          # Additional Terms
      L += term.form_term_rhs(state, w) * state.dx('magnetic')
      a += term.form_term_lhs(state, w, Constant(0.5 * dt) * v) * state.dx('magnetic')

    #######################################################
    # Assembly
    #######################################################

    # assemble llg
    t0 = time.time()
    A = assemble(a)
    A.ident_zeros()
    b = assemble(L)

    # assemble constraint
    B  = DofAssembler.assemble(ScalarProductMatrix(VS, VV, state.m))
    BT = DofAssembler.assemble(TransScalarProductMatrix(VS, VV, state.m))

    # assemble block matrix
    AA = block_mat([[A, BT],
                    [B, 0]])
    bb = block_vec([b, BT.create_vec()])

    Ap = ILU(A)
    Bp = InvDiag(collapse(B*LumpedInvDiag(A)*BT))
    AAp = block_mat([[Ap, BT],
                     [0, -Bp]]).scheme('sgs')

    #######################################################
    # Solve the system
    #######################################################
    AAinv = BiCGStab(AA, precond=AAp, tolerance=1e-8/dt)
    u, foo = AAinv*bb

    v = Function(VV)
    v.vector()[:] = u

    print "LLG: %s" % (time.time() - t0)
    return v

  def step(self, state, dt):
    """
    Calculate :math:`\\vec{m}(t+\Delta t)` for a given timestep.

    *Arguments*
      state (:class:`State`)
        The magnetization configuration.
      dt (:class:`float`)
        The time-step size.
    """

    v = self.calculate_v(state, dt)
    # XXX find simpler way for the following
    state.m.vector().axpy(dt, v.vector())
    state.m.assign(Function(
        state.m.function_space(),
        DofAssembler.assemble(NormalizedVector(state.m.function_space(), state.m))
    ))
